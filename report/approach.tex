\chapter{Approach}
\label{method}
\section{Overall methodology}

When making projects, the approach can be
more or less bottom-up or top-down.
A top-down approach could be like the waterfall model\cite{waterfall} of software devlopment,
where we start with the specification, design and then implementation and test.
The bottom-up is could be like stepwise refinement\cite{stepwise-refinement}, more agile\cite{agile-manifesto, extreme-programming}, starting out with a quick prototype, which gets more and more refined.

The purpose of this project is to learn about programming languages and mobile development, and create a scripting language. 
The bottom-up approach is choosen, as it opens more up for experimentation, and new ideas are easier follow, than with the top-down approach.

The methodology of the project is to make a series of prototypes related to mobile scripting language implementation, while surveying the field. 
The best parts of the prototypes are expanded and built further on, to get the scripting language, while documenting and specifying the language in parallel.

\subsection{Prototypes}
The design and implementation of the languages is not just a single design, but comes through ca. 30 prototypes of aspects of the languages.
This leads up to LightScript and Yolan, which will be described in the next chapters.
Discarded prototypes include a Forth-like language, several parser/compiler implementations on top of JavaScript, a couple of virtual machins on the jvm, some experiments towards an implementation in C, experiments with mobile applications and their GUI, and drafts of parts of what becomes LightScript and Yolan.

\section{Some design choices}

This section looks defines some of common the overall design choices and goals for the languages of the project.

The major target platform should be Java Mobile Edition CLDC/1.0, as this is the most limited platform that I have access to. 
If the language runs on top of CLDC/1.0, it will also be able run on other device configurations, with minor change, which is most mobile devices.

The language should be easy to embed, so when targeting the JVM, most of the datatypes should map directly to standard Java classes, in order to make it easier for the developers to interface with the scripting language from the host application.

As with most other scripting languages, the type system should be dynamic. 

The parser may assume that the programs have valid syntax. 
Usually parsers both build a syntax tree of valid programs and also reject programs with invalid syntax. 
By removing the rejecting-part, and only require that the can parsers build a syntax tree from valid programs, the parser may be optimised to run better on the limited devices.
The parser should still be robust and terminate, even with invalid programs though the resulting syntax tree may be strange.

Execution should be online, in the sense that whenever a full statement is read from the input, it should be executed, not needing to read the full file. This is both practical for interactive evaluation, and also has a benefit memorywise as the entire program never needs to be fully in memory, as executed code may be garbage collected.

The language implementations are experimental proof-of-concepts. They may be worth building further on, but they are not fully mature languages from the begining.

The design should be inspired by EcmaScript/JavaScript, as this is the most widely deployed scripting language, and would thus be a good translation target for the scripting language implemented here.

Access to variables should be optimised to be reasonably fast, as the target platform is already very slow. 
This rules out implementation techniques of looking up variables at run time by traversing a stack, or looking up the name in a table.

\section{Evaluation}
The evaluation should compare the code footprint and execution speed of the the developed languages, with existing scripting language.
In addition to this, it could also be interesting to look at how different parts of a language implementation adds to the code footprint.

\section{Summary}
