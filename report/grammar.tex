\chapter{Grammar}
This Chapter has the grammar for Yolan and LightScript.
Literal characters are writen with single quotation mark.
Ranges of possible characters are written within square brackets, such that \verb|[a-c]| means one of the characters a, b or c. Ranges can also be negated, such that \verb|[^a-cf]| means a character that is not a, b, c nor f. A range can also contain escaped characters: \verb|\0| means the character with unicode value 0, and \verb|\\| means the backslash character. \verb|\[|, \verb|\]|, and \verb|\-| means \verb|[|, \verb|]| and \verb|-|. \verb|\n|, \verb|\r|, and \verb|\t| means new line, carriage return, and tab.

Grammar productions are defined with \verb|::=|, parentheses are used for grouping and \verb\|\ is means or. \verb|*| is notation for zero or more occurences of the previous element.

\section{Yolan}
\begin{verbatim}
<empty expression>  ::= 

<number>            ::= [0-9][0-9]*

<identifier>        ::= [^\0- "0-9;\[\]] [^\0- \[\]]*

<comment>           ::= ';' [^\0-\n]* [\0-\n]

<string>            ::= '"' ( [^"] | '\' [\\"] )* '"'

<white space>       ::= [\0- ] 
                      | <white space> <comment>

<white spaces>      ::= <white space>
                      | <white space> <white spaces>

<optional ws>       ::= <empty expression> 
                      | <white spaces>

<expressions>       ::= <expression>
                      | <expression> <white spaces> <expression list>

<expression list>   ::= <optional ws> <expressions> <optional ws>

<expression>        ::= '[' <expression list> ']'
                      | <identifier>
                      | <string>
                      | <number>

<program>           ::= <expression list>
\end{verbatim}

\section{LightScript}
The first section described the LightScript grammar via top down operator precedence functions.
The second section describes the LightScript grammar as a traditional grammar.

\subsection{Grammar for tokens}
\begin{verbatim}
<number>            ::= [0-9] [0-9]*

<name>              ::= [_a-zA-Z] [_a-zA-Z0-9]*

<string>            ::= '"' ( [^"] | '\' [\\"n] )* '"'

<comment>           ::= '//' [^\n]* [\n]

<white space>       ::= [ \n\r\t] 
                      | <comment>
                      | <white space> <white space>

<long symbol>       ::= [=!<&|+*/\->%]

<single symbol>     ::= [(),.:;?\[\\\]^{}~]

<symbol>            ::= <long symbol> <long symbol>*
                      | <single symbol>

<literal>           ::= <number> | <string>

<identifier>        ::= <name> | <symbol>

<token>             ::= <literal> | <identifier>

<program>           ::= ( <token> | <white space> )*
\end{verbatim}

\subsection{Top down operator precedence functions}
\verb|<literal>|s are mapped to a syntax tree node which represent a literal value.
If an \verb|<identifier>| is within the table below, the corresponding function are called in the top down operator precedence parser, otherwise the \verb|<identifier>| is just viewed as a reference to a variable.
\begin{center}
\begin{tabular}{lccr}
Tokens & Null denominator & Left denominator & Precedence \\
\verb|.| & & Infix & 7 \\
\verb|( [| & List & Infix list & 7 \\
\verb|/ * % >> /| & & Infix & 6 \\
\verb|+| & & Infix & 5 \\
\verb|-| & Prefix & Infix & 5 \\
{\tt == === != !== } & & Infix & 4 \\
{\tt <= < > >=} & & Infix & 4 \\
\verb+&& || else in+  & & Right infix & 3 \\
\verb|?|  & & Infix3 & 3 \\
{\tt = += -= *= /= \%=} & & Right infix & 2 \\
\verb|function|  & Function case& & \\
\verb|: ; ,|  & Separator & & \\
\verb|] ) }|& List end & & \\
{\tt try catch do }  & Prefix2 & & \\
{\tt for if while }  & Prefix2 & & \\
{\tt ++ -- ! }  & Prefix & & \\
{\tt return throw var}  & Prefix & & \\
{\tt undefined null}  & Single & & \\
{\tt true false this}  & Single & & \\
literal identifier  & Single & & \\
\verb|{|  & List & & \\
\end{tabular}
\end{center}
``Infix'' joins the previous and the next expression in a left skewed tree, whereas ``Right infix'' joins the previous and next expression in a right skewed tree. ``Infix3'' creates a node which combines left expression and the next three right expressions. ``InfixList'' creates a node which takes the previous expression, and reads the next expressions until a ``List end'' is found.

``List`` reads the next expression until a ``List end'' is found. ``Single'' creates a leaf in the syntax tree. ``Prefix'' create a node with the next read expression. ``Prefix2'' create a node with the two next expressions read. ``List end'' is a special node used for terminate lists. ``Separator''s are special nodes, that may be discarded during compilation. ``Function case'' handles \verb|function|s which is a ``Prefix2'' or ``Prefix3'' depending on whether the first parsed expression is a list or identifier. 

\subsection{Grammar}
\begin{verbatim}
<prefix name>       ::= '-' | '++' | '--' | '!' 
                      | 'return' | 'throw' | 'var' 

<prefix2 name>      ::= 'try' | 'catch' | 'do' | 'for' | 'if' | 'while'

<single>            ::= 'undefined' | 'null' | 'true' | 'false'
                      | 'this' | <identifier> | <literal>

<separator>         ::= ':' | ';' | ','

<list start>        ::= '[' | '{' | '('

<list end>          ::= ']' | '}' | ')'
                      | <expr> <list end>

<list>              ::= <list start> <list end>

<function>          ::= 'function' <list> <expr>
                      | 'function' <identifier> <list> <expr>

<expr8>             ::= <prefix> <expr>
                      | <prefix2> <expr> <expr>
                      | <single>
                      | <separator>
                      | <list>
                      | <function>

<expr7>             ::= <expr8>
                      | <expr7> '.' <expr8>
                      | <expr7> ('(' | '[') <list end>

<expr6 operator>    ::= '/' | '*' | '%' | '>>' | '/'

<expr6>             ::= <expr7>
                      | <expr6> <expr6 operator> <expr7>

<expr5>             ::= <expr6>
                      | <expr5> ('+' | '-') <expr6>

<expr4 operator>    ::= '==' | '===' | '!=' | '!==' 
                      | '<=' | '<' | '>' | '>='

<expr4>             ::= <expr5>
                      | <expr4> <expr4 operator> <expr5>


<expr3 operator>    ::= '&&' | '||' | 'else' | 'in' 

<expr3>             ::= <expr4>
                      | <expr4> <expr3 operator> <expr3>
                      | <expr3> '?' <expr3> <seperator> <expr3>

<expr2 operator>    ::= '=' | '+=' | '-=' | '*=' | '/=' | '%='

<expr>              ::= <expr3>
                      | <expr3> <expr2 operator> <expr>

<program>           ::= <expr>*

\end{verbatim}
