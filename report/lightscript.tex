\chapter{* LightScript}
\label{lightscript}
\index{LightScript}
\section{* Design choices}

The paragraphs below, elaborates on the following design choices:
null-is-false
javascript-like scope

\begin{itemize}
\item LightScript should be based on EcmaScript, and run within EcmaScript interpreters.
\item 
\end{itemize}

LightScript should be based on EcmaScript, such that LightScript scripts runs without modification within an EcmaScript interpreter. 
This will make it possible to use LightScript to write applications that both run on low end mobile devices and also in web browsers, binding those two platforms together.
It also makes it easier for EcmaScript/JavaScript programmers to learn LightScript.
It is not possible to make LightScript EcmaScript compliant, as EcmaScript has requirements that are not possible to fullfill on low end mobile devices.

\subsection{*Design choices from the platform}

As CLDC/1.0 is target, there are no support for floating point numbers in the vm,
and thus all numbers in LightScript will be integers, which opposite to EcmaScript
where the numbers are floating point.
For addition, subtraction, multiplication, and remainder of division, the results are equivalent of floats and integers, if we start out with integers and do not have overflows. The division operator has the issue that it yields different results on integers and floats, so the \verb|/| operator is not implemented. Instead it is possible to make an integer division function \verb|div(a, b)|, both on top EcmaScript and as a Java function exported to LightScript.
Casting to integers in the EcmaScript can be done like:
\verb~function div(a, b) { return (a/b)|0; }~
The limits of the low end mobile devices also encourages choosing the simple and fast solutions.

A design question is also the implementation of truth values. 
One question here is whether to have a distinct Boolean type and undefined type or just let 
\verb|null|, \verb|false| and \verb|undefined| be the same.
The distinction \verb|false| and \verb|undefined| can be practical\cite{luahopl}, as it for example allows on to see if a value in a table has been set to \verb|false|, or just not been set yet.
On the other hand, a unified null value is simpler and faster as truth tests are then just comparision with null, so LightScript only has the value \verb|null| as a false value, and true is just "true". 
This is different from EcmaScript where \verb|false|, \verb|null|, \verb|undefined|, \verb|0|, and \verb|""| are all false, so for compatibility, a requirement should be added, that numbers and strings should not be used directly as boolean values, which is also good coding style. 


\subsection{Implemented parts of EcmaScript, and strictness}
This first implementation of LightScript will not try to implement as much of EcmaScript as possible, but rather implement enough such that it is useful, and avoid parts of the language that is considered bad style.

EcmaScript it has objects with prototypical inheritance, but instead of a self like clone operator\cite{See section~\ref{survey-self}}, it adds some apparantly Java inspired syntax with a \verb|new| operator, coupled with a special prototype property.
Instead of the Java inspired \verb|new| syntax for instantiation, LightScript just supports objects inheritance the clone operator, which can easily be implemented in pure EcmaScript as well.




\subsection{*Design choices and differences from EcmaScript/JavaScript}




\subsection{*Scoping and stack}

LightScript should have static scope, in a way similar to EcmaScript. 

\section{* Implementation details}
\subsection{** Imperative top down operator precedence parser}
The top down operator precedence parser described in section~\ref{tdop} is targeted functional languages.
This section looks at how it can be implemented efficiently in more imperative languages, where first class functions may nor be available or be expensive.

The purpose of the parser is to transform a stream of tokens into a parser tree.
Tokens comes in as strings, and each node in the resulting parse tree is a list with the kind of node as the first elements, followed by child nodes or literal values.
Such that an expression such as \verb~f = function(x) { return x * 41 + x; }~, would come to the parser as the sequence of: 
"function", "f", "(", "x", ")", "{", "return", "x", "*", "41", "+", "x", ";", "}",
which could
then be transformed into a parse tree a la: (set (id "f") (function (parameters (id "x")) (block (return (add (multiply (id "x") (literal 42)) (id "x")))))).


To reduce the code size of the parser, we assume that the source code is well formed, and do not require that the parser reports syntax errors. This for example removes the need for keeping track of where we are in the code and also allows some tokens to be joined, for example list termination does need not distinguish between different kinds of list.

In the descriptions of the top down operator precedence parser \cite{tdop,beautifulcode}, each token has some functions that are called during parsing. 
The first observation is that there are two kinds of functions connected to the tokens: null denominator functions, and left denominator functions. 
Instead of having an object/class for each of the many functions that can be connected to the token, significantly space can be saved by just create a function with a dispatch for each of the two kinds of functions.
So instead of the token has a two function objects for the null denominator function and left denomintator function, it just has two indices which are used in the corresponding function dispatch.

...


\subsection{* Implementation of variables and scope}
In the EcmaScript standard, identifier resolution is done by searching through the scope chain, which is a list of objects. Objects in the EcmaScript context is a mapping from property names to values. This approach to implementation would be very performance expensive.

Instead we want to resolve the variables at compile time, while preserving as much of the semantics as is practical. The main issue here is that we when we resolve the variable at compile time, we do not keep information to be able to resolve dynamically at run time, not supporting access to local variable with \verb|eval| statements, but as mentioned in section~\ref{designstyle}, eval is not availble in the first version of the language (though it could easily be added as an external java function that just calls LightScript).
The implementation of scope has already been discussed in section~\ref{survey-scope}, and for this implementation the choice is to store the variables in the activation record, which is placed linearly on a stack -- as this approach is known to work efficiently. 
If a value are going to be in the closure of a sub-function in the inner scope, it gets boxed on the stack, and needs to be garbage collected.

For the practical implementation of the stack on top of the jvm, there are two obvious possibilities: A \verb|java.util.Stack| could be used, or a stack could be implemented manually with an array and an index pointer. 
In order to select implementation strategy, a microbenchmark was done on the kvm, which indicated that the array approach is significantly faster than the \verb|java.util.Stack|. The array grows dynamically when entering a function which uses more stack spaces than is available. 
The code footprint size is similar for both approachs, though probably a bit smaller for the Stack, as that one automatically grows, unlike then the array approach, which need a manual implementation.
The actual access to a \verb|Stack| requires a method calls, which are 3 bytes plus 1-3 bytes for self and parameter loading, where reading from an array is a single byte opcode plus 2-4 bytes for self, index and parameter loading, and at the same time the array approach sometimes need to adjust the index, costing 3 bytes.

\section{* Language specification}
\section{* Developers guide}
\section{* Summary}
