\chapter{* LightScript}
\label{lightscript}
\index{LightScript}
\section{* Design choices}

The paragraphs below, elaborates on the following design choices:
null-is-false
javascript-like scope

\begin{itemize}
\item LightScript should be based on EcmaScript, and run within EcmaScript interpreters.
\item 
\end{itemize}

LightScript should be based on EcmaScript, such that LightScript scripts runs without modification within an EcmaScript interpreter. 
This will make it possible to use LightScript to write applications that both run on low end mobile devices and also in web browsers, binding those two platforms together.
It also makes it easier for EcmaScript/JavaScript programmers to learn LightScript.
It is not possible to make LightScript EcmaScript compliant, as EcmaScript has requirements that are not possible to fullfill on low end mobile devices.

\subsection{*Design choices from the platform}

As CLDC/1.0 is target, there are no support for floating point numbers in the vm,
and thus all numbers in LightScript will be integers, which opposite to EcmaScript
where the numbers are floating point.
For addition, subtraction, multiplication, and remainder of division, the results are equivalent of floats and integers, if we start out with integers and do not have overflows. The division operator has the issue that it yields different results on integers and floats, so the \verb|/| operator is not implemented. Instead it is possible to make an integer division function \verb|div(a, b)|, both on top EcmaScript and as a Java function exported to LightScript.
Casting to integers in the EcmaScript can be done like:
\verb~function div(a, b) { return (a/b)|0; }~
The limits of the low end mobile devices also encourages choosing the simple and fast solutions.

A design question is also the implementation of truth values. 
One question here is whether to have a distinct Boolean type and undefined type or just let 
\verb|null|, \verb|false| and \verb|undefined| be the same.
The distinction \verb|false| and \verb|undefined| can be practical\cite{luahopl}, as it for example allows on to see if a value in a table has been set to \verb|false|, or just not been set yet.
On the other hand, a unified null value is simpler and faster as truth tests are then just comparision with null, so LightScript only has the value \verb|null| as a false value, and true is just "true". 
This is different from EcmaScript where \verb|false|, \verb|null|, \verb|undefined|, \verb|0|, and \verb|""| are all false, so for compatibility, a requirement should be added, that numbers and strings should not be used directly as boolean values, which is also good coding style. 


\subsection{Implemented parts of EcmaScript, and strictness}
This first implementation of LightScript will not try to implement as much of EcmaScript as possible, but rather implement enough such that it is useful, and avoid parts of the language that is considered bad style.

EcmaScript it has objects with prototypical inheritance, but instead of a self like clone operator\cite{See section~\ref{survey-self}}, it adds some apparantly Java inspired syntax with a \verb|new| operator, coupled with a special prototype property.
Instead of the Java inspired \verb|new| syntax for instantiation, LightScript just supports objects inheritance the clone operator, which can easily be implemented in pure EcmaScript as well.




\subsection{*Design choices and differences from EcmaScript/JavaScript}




\subsection{*Scoping and stack}

LightScript should have static scope, in a way similar to EcmaScript. 

\section{* Implementation details}
\subsection{Optimised imperative top down operator precedence parser}
The top down operator precedence parser described in section~\ref{tdop} is targeted functional languages.
This section looks at how it can be implemented efficiently in an imperative language.

To reduce the code size of the parser, we assume that the source code is well formed, and do not require that the parser reports syntax errors. This for example removes the need for keeping track of where we are in the code and also allows some tokens to be joined, for example list termination does need not distinguish between different kinds of list.

First class functions use a lot of space in the Java platform, as they require a class each.
The solution is to use a dispatch function instead, and replace the function properties of the token, with integers.
Actually it is simpler with two dispatch functions, one for the null denominator functions and one for the left denominator functions.

The token object contains information about the denominator functions, and corresponding abstract syntax tree node IDs, and also a priority/binding power.
This is just five small integers, which, due to their limited range, easily can be represented in a single 32bit integer. 
Some tokens represents literal values or identifier, where the value or identifier also has to be passed to the parser.
So a token can be represented compactly by adding two properties to the parser: an integer and possible an object for the value, rather than a new class/object.

The token types can be encoded by the token string followed by the five integers.
So the tokens can be written as {\tt "tokenname" + (char) binding\_power + 
(char) null\_denominator\_function + (char) AST\_ID\_for\_null\_denominator
(char) left\_denominator\_function + (char) AST\_ID\_for\_left\_denominator
}. 
So the task of writing the parser is to make a list of tokens, connected with their binding power, denominator function ids and abstract syntax tree ids, -- a simple parse loop, plus definition of sensible denominator function bodies in the dispatch.


\subsubsection{Performance properties of the implementation}

For each token, there is a instruction cost of 1-2 function calls, 1 switch-dispatch, 0-1 comparison, reading of 2-3 properties of the token object, and storing a copy of the token val, plus the cost of building the actual AST node, and the cost of parsing the token.

The size of the implementation can be kept very small, as the denominator functions can be reused across different token-types. For example: the binary operators share a single case in the left denominator dispatch, and adding a new binary operator only takes the length in characters of the operator plus 5 bytes. 

\subsection{Implementation of variables and scope}
In the EcmaScript standard, identifier resolution is done by searching through the scope chain, which is a list of objects. Objects in the EcmaScript context is a mapping from property names to values. This approach to implementation would be very performance expensive.

Instead we want to resolve the variables at compile time, while preserving as much of the semantics as is practical. The main issue here is that we when we resolve the variable at compile time, we do not keep information to be able to resolve dynamically at run time, not supporting access to local variable with \verb|eval| statements, but as mentioned in section~\ref{designstyle}, eval is not availble in the first version of the language (though it could easily be added as an external java function that just calls LightScript).

Of the different implementation methods discussed in section~\ref{survey-scope}, the only real possibilities for a partly imperative scripting language which also want good support for higher order functions are either to allocate the activation records on the heap, or keep track of variables that could live on after exiting a function, and box those variable on the heap.
The other options are ruled out, as we want to have closures, and we want the outer scope variables to be mutable.
Allocating the activation records on the heap has the issue, that we are not in control of the garbage collector, and it may not be designed for that kind of usage, leading to expensive performance, so the approach will be only to box variables onto the heap, that could be alive after function exit.

To simplify this, it is done such that every variable that is added to a closure of an inner function is boxed on the heap, and other local variables are just stack allocated in the usual way. 
I have not seen this exact approach to implement closures other places, but it seems so obvious, that it is probably done somewhere before, although it clearly is different from the Lua approach with upvals\cite{luasrc}, and also from the approach following the EcmaScript standard\cite{ecmascript} directly.

For the practical implementation of the stack on top of the jvm, there are two obvious possibilities: A \verb|java.util.Stack| could be used, or a stack could be implemented manually with an array and an index pointer. 
In order to select implementation strategy, a microbenchmark was done on the kvm, which indicated that the array approach is significantly faster than the \verb|java.util.Stack|. The array grows dynamically when entering a function which uses more stack spaces than is available. 
The code footprint size is similar for both approachs, though probably a bit smaller for the Stack, as that one automatically grows, unlike then the array approach, which need a manual implementation.
The actual access to a \verb|Stack| requires a method calls, which are 3 bytes plus 1-3 bytes for self and parameter loading, where reading from an array is a single byte opcode plus 2-4 bytes for self, index and parameter loading, and at the same time the array approach sometimes need to adjust the index, costing 3 bytes.

\section{* Language specification}
\section{* Developers guide}
To evaluate code with LightScript, you first have to instantiate a LightScript object, which keeps track of global values, loaded libraries, and other stuff. The constructor takes no parameters, so creating it is just:
\begin{lstlisting}
    LightScript lsContext = new LightScript();
\end{lstlisting}
This context can then be used to evaluate LightScript code, using the \verb|eval| method. This method either takes a string or an \verb|java.io.InputStream| as parameter, which is then read and executed:
\begin{lstlisting}
    lsContext.eval("print(\"Hello world \" + 17 * 42)");
    lsContext.eval(new FileInputStream(new File("myscript.js")));
\end{lstlisting}
Global variables of the context can be read and written with the \verb|get| and \verb|set| method, so for example:
\begin{lstlisting}
    lsContext.set("foo", new Integer(17));
    lsContext.eval("bar = foo + 25;");
    System.out.println(lsContext.get("bar");
\end{lstlisting}
would print \verb|42|.

\subsection{Adding native functions to the runtime}

A method on a Java object can be called from LightScript if it implements the \verb|LightScriptFunction| interface, which defines an \verb|apply| method.
The interface is:
\lstinputlisting{../code/LightScript/LightScriptFunction.java}
So for example a function that returns the current number of milliseconds could be implemented as:
\begin{lstlisting}
class MillisecondsFunction implements LightScriptFunction {
    public Object apply(Object thisPtr, Object[] args, int argpos, 
                        int argcount) throws LightScriptException {
        return new Integer((int)System.currentTimeMillis());
    }
}
\end{lstlisting}

Adding a function to the runtime, is just like adding any other variable,
via using the \verb|put| method of the LightScript object.
So using the function above measuring some timings in LightScript can be done like:
\begin{lstlisting}
    lsContext.set("timer",new MillisecondsFunction());
    lsContext.eval("begin = timer();"
                  +"for(i=0;i<1000000;++i);"
                  +"print(\"Time used: \" + (timer() - begin));");
\end{lstlisting}

When registrering several functions, it is more compact to join them via a dispatch, 
so a class implementing a couple of functions could be implemented like:
\begin{lstlisting}
class FunctionLibrary implements LightScriptFunction {
    int id; // This tells which function the object represents
    public Object apply(Object thisPtr, Object[] args, int argpos, 
                        int argcount) throws LightScriptException {
        switch(id) {
            case 0: // integer division
                return new Integer(((Integer)args[argpos]).intValue()
                                  /((Integer)args[argpos+1]).intValue());
            case 1: // increment property i, not of superclass
                int i = ((Integer)((Hashtable)thisPtr).get("i")).intValue();
                ((Hashtable)thisPtr).put("i", new Integer(i + 1));
        }
        return null;
    }
    private FunctionLibrary(int id) { this.id = id; }
    public static void register(LightScript lsContext) {
        lsContext.set("div", new FunctionLibrary(0));
        lsContext.set("propinc", new FunctionLibrary(1));
    }
}
\end{lstlisting}
which could be used like:
\begin{lstlisting}
    FunctionLibrary.register(lsContext);
    lsContext.eval("obj = {}; obj.i = 1; obj.inc = propinc;"
                  +"while(obj.i < 10) {"
                  +"  print(div(42, obj.i));"
                  +"  obj.inc();"
                  +"}");
\end{lstlisting}

\subsection{Datatypes}
LightScript uses ordinary Java objects for most data.
Strings, stacks, tables, are as usual Java.
Boolean values are the constants \verb|LightScript.TRUE| and \verb|LightScript.FALSE|, which are not Java Booleans, but the string "true" and null.

LightScript objects with inheritance are instances of the \verb|LightScriptObject| class, which is subclass of \verb|java.lang.Hashtable|. LightScript objects have a constructor that corresponds to clone in Self, se section~\ref{survey-self}, and the parameter to the constructor is a hashtable or a LightScript object. The LightScript objects also overloads the hashtable get operator to access the cloned object, if the key was not found in this one.

Exceptions that can be thrown to/from LightScript are of the class \verb|LightScriptException|. This exception has a property \verb|value| that is the object that is thrown/caught within LightScript. The constructor just take the value as parameter.


\section{* Summary}
