%Functions takes a number, possibly zero, of arguments and always return one value.
%They are in list notation as \verb|[|$function$ $argument_1 \cdots argument_n$\verb|]|.
%Functions defined within the language are eagerly evaluated: $argument_1\cdots argument_n$ are evaluated before the function is called, with $argument_1$ evaluated first and $argument_n$ evaluated last.
%Builtin functions and foreign functions may not evaluate all argument and may evaluate some arguments several times. This is used to built control structures such as \verb|if| and \verb|while|.
%Lists are evaluated as function calls.
%Identifiers are evaluated into the value the identifier is set to represent via the \verb|set| function.
%Literal integer and string values are evaluated into their respective values.
%NB: concatenative intermediate code

This chapter specifies the Yolan programming language.
The purpose of the language is to enable high level scripting on low end mobile devices. Language features include:
\begin{itemize}
\item Designed for minimal code footprint in Java Mobile Edition, which is the most limiting factor on the lowest end mobile devices, for user applications
\item Designed with implementations in C on embedded devices and implementations on top of EcmaScript in mind.
\item Dynamic scripting language with lisp-like syntax
\item Functions as first class values, support for higher order functions
\item Standard library with dictionaries, lists/vectors/stacks, iterators, strings and integers
\end{itemize}

The chapter starts by describing the syntax, then gives an overview of the types, the presents the semantics of the evaluation, and finally specifies the standard library.


\section{Syntax}
Programs consist of lists of either lists, variable names, or literals.
The notation is very similar to lisp where function application is written as lists.
The difference is that square brackets are used rather than parenthesis, 
as the lists are just function applications and very different from lisp-lists.
The motivation behind this syntax, is that it makes it possible to make a very small parser code footprint, while still having a syntax that can feel somewhat familiar.

\subsubsection{Function application}
Function application is written as lists enclosed within square brackets \verb|[ |$\cdots$\verb| ]|, and may be nested. The elements within the lists are seperated by whitespaces. A list must have at least one element, which is the function that is called.

\subsubsection{Variable names}
A variable name is a sequence of symbols. The possible symbols are letters, numbers, the symbols \verb]!#$%&'()*+,-./:<=>?@\^_`{|}~], and any symbol with an unicode value of 127 or higher. The first symbol must be non-numeric.

\subsubsection{String literals}
Strings are enclosed by double quotes \verb|"|. Backslash \verb|\| can be used for escaping double quotes and backslashes within the string, e.g. the string containing the characters \verb|"\|, would be written \verb|"\"\\"|.

\subsubsection{Integer literals}
Integers are written as a series of numbers (\verb|0123456789|). Only base 10 input is possible and only non-negative numbers can be written as literals, where their negative counterparts must be generated by subtraction.

\subsubsection{Comments and whitespaces}
Symbols with an unicode value of 32 or less are regarded as whitespaces. This includes the usual space, tab, newline, line-feed. Whitespaces are used to seperate list elements, and are discarded during parsing.
Comments must follow a whitespace, and starts with a semicolon \verb|;| and continues until the end of the line. They are discarded during parsing. 


\section{Types and values}
The language is dynamically typed.
The core language contains the following types: nil, integer, string, list dictionary, iterator and user defined function.

Nil is the type of the nil value, and only has that single value. It is also equivalent to null, undefined and false in other languages.

Integers is the only builtin number type, but other may be added through libraries. The possible range depends on implementation, it will typically be 32 bit, but implementations may have as little as 15bit precision (range $-16384\cdots 16383$).

Strings are immutable sequences of characters.

Lists are mutable variable size sequences of data. It should be possible to read or write an element in any position of the list in constant time. The list is also resisable, and should also be able to act as a stack. 
Lists are zero-indexed, so the first element has the id 0, and the last element has the id as the length of the list minus one.

Dictionaries are mappings between keys and values. Keys must be integers or strings, and values can be any type except nil. Keys which are numbers written as strings may or may not map to the same integer-key, depending on implementation. Access time may be linear in the size of the dictionary in worst case.

Iterators are sequences of values. An iterator can for example be used to walk through the values of a list or the keys of a dictionary. 

Functions are defined by the lambda-operator or defun, and can be passed around like any other value, and are applied with the usual list notation.

\section{Evaluation}

The language consists of literals, variable names and function applications.
Literals are evaluated into their literal values, 
variable names are evaluated by looking up the corresponding value, and
function applications are evaluated by executing the function.
Details on how variables and functions work is described in the following sections.

\subsection{Variables}

A variables can be thought of as simple mapping from a name to a value.
Evaluation of a variable just replaces the name with the corresponding value if there is a mapping from the name, or else it evaluates to nil.
The function \verb|set| can be used to add or change the mappings. Setting a variable name to map to nil has the same effect as deleting it.
It is possible to have local variables for a piece of code, by saving the mappings right before entering the code, and restore them after exiting it.

The mappings are updated across time and thus it has dynamic scope rather than static scope. Static scope is more natural as it matches the lexical structure better, and it also makes functions more expressive by enabling closures, so dynamic scope is generally a bad idea, but in this case it is outweighted by the concerns regarding code footprint, where dynamic scope uses significantly less space. 
See also section~\ref{funarg} further discussion on this point.

Implementations should not do a full lookup of a name at each evaluation, but should instead replace the name with a reference to the memory cell where the value for that name is stored.

\subsection{Functions}

Functions calls are written in list notation similar to lisp notation, but with square bracket, e.g.:
{\tt{[}$function$ $parameter_1\cdots parameter_n$\tt{]}}. 
Notice that $function$ and $parameter_1\cdots paramenter_n$ are expressions which means that they have to be evaluated.

When a function is called, the first thing that happens is that the $function$ expression is evaluated. The result may be cached by the runtime, which means that if the $function$ may change between evaluations, it should be evaluated by the builtin \verb|apply| function.
Evaluation of $function$ should either yield a builtin function, a foreign function on the host platform, or a user defined function. If it is a user defined function, the parameters are evaluated and then the function is called. If it is a builtin or foreign function, the parameters are passed as delayed computations, where the called function is responsible for evaluating them. 
This is what makes it possible to implement conditionals and repetition as ``functions''. 

Details of user functions are described under the \verb|lambda| builtin function below. The builtin functions are described below, and for details about foreign function interface, see the corresponding developers guide.


\section{Builtin functions}
The builtin functions are listed in the following sections. As the language is designed for embedding in other applications, there are no standard input/output functions, file access, network, etc. as these might not be present or differ significantly between target device/platform. 
\subsection{Variables}
\subsubsection{\tt{[set }$name$ $value$\tt{]}}
Evaluate $value$ and let $name$ refer to the result.

\subsubsection{\tt{[locals [}$name_1 \cdots name_n$\tt{]} $expr_1 \cdots expr_n$\tt{]}}
Let $name_1 \cdots name_n$ be local variables in $expr_1 \cdots expr_n$: First save the values corresponding to $name_1 \cdots name_n$, then evaluate $expr_1 \cdots expr_n$, next restore the values of $name_1 \cdots name_n$ and finally return the result of the evaluation of $expr_n$.

\subsection{Conditionals and logic}
\subsubsection{\tt{[if }$cond$ $expr_1$ $expr_2$\tt{]}}
Evaluate $cond$ and if the result is non-$nil$ then evaluate and return $expr_1$, else evaluate and return $expr_2$.

\subsubsection{\tt{[not }$cond$\tt{]}}
If $cond$ is $nil$ return $true$ else return $nil$.

\subsubsection{\tt{[and }$expr_1$ $expr_2$\tt{]}}
Evaluate $expr_1$ and if it is non-$nil$, evaluate and return the value of $expr_2$, else return $nil$.

\subsubsection{\tt{[or }$expr_1$ $expr_2$\tt{]}}
Evaluate $expr_1$ and if it is non-$nil$ return its value, else evaluate and return the value of $expr_2$.

\subsection{Repetition and sequencing}
\subsubsection{\tt{[repeat }$num$ $expr_1 \cdots expr_n$\tt{]}}
Evaluate $expr_1 \cdots expr_n$ $num$ number of times ($num$ must be a non-negative integer). The result is the last execution of $expr_n$, or $nil$ if no expressions were evaluated.

\subsubsection{\tt{[foreach }$name$ $iterator$ $expr_1 \cdots expr_n$\tt{]}}
For every value from the $iterator$, bind it to the local $name$ and evaluate $expr_1 \cdots expr_n$. The result of the evaluation is the last executed $expr_n$ or $nil$ if no expressions were evaluated. $name$ is a local variable, and is thus saved before the loop, and restored afterwards.

\subsubsection{\tt{[while }$cond$ $expr_1 \cdots expr_n$\tt{]}}
While $cond$ evaluates to non-$nil$, evaluate $expr_1 \cdots expr_n$, and return the value of the last $expr_n$ or $nil$ if no expressions was evaluated.


\subsubsection{\tt{[do }$expr_1 \cdots expr_n$\tt{]}}
Evaluate $expr_1 \cdots expr_n$ and return the result of $expr_n$.


\subsection{Functions}
\subsubsection{\tt{[lambda [}$name_1 \cdots name_n$\tt{]} $expr_1 \cdots expr_n$\tt{]}}
Create a new anonymous function, with the parameters $name_1\cdots name_n$. Application of the function will bind its arguments to locale variables $name_1\cdots name_n$, evaluate $expr_1\cdots expr_n$ and return $expr_n$.
\subsubsection{\tt{[defun [}$name_{function}$ $name_1 \cdots name_n$\tt{]} $expr_1 \cdots expr_n$\tt{]}}
Create a new function, and bind it to the variable $name_{function}$. It is equivalent to {\tt{[set }}$name_{function}${\tt{ [lambda [}}$name_1 \cdots name_n${\tt{]}} $expr_1 \cdots expr_n${\tt{]]}}.

\subsubsection{\tt{[apply }$function$ $param_1 \cdots param_n$\tt{]}}
Apply the $function$ to the parameters $param_1\cdots param_n$. The difference between this and the usual function application {\tt{[}$function$ $param_1\cdots param_n$\tt{]}} is that that \verb|apply| allows $function$ to change between invocations, whereas the usual function application assumes that $function$ is static to be able to optimise it during runtime.

\subsection{Integer operations}
\subsubsection{\tt{[+ }$num_1$ $num_2$\tt{]}}
Calculate the sum of two integers.
\subsubsection{\tt{[- }$num_1$ $num_2$\tt{]}}
Calculate the difference of two integers, the result is $num_2$ subtracted from $num_1$.
\subsubsection{\tt{[* }$num_1$ $num_2$\tt{]}}
Calculate the product of two integers.
\subsubsection{\tt{[/ }$num_1$ $num_2$\tt{]}}
Integer division, $num_1$ is divided by $num_2$.
\subsubsection{\tt{[\% }$num_1$ $num_2$\tt{]}}
Returns the remainder of $num_1$ divided by $num_2$.

\subsection{Type conditionals}
\subsubsection{\tt{[is-integer }$val$\tt{]}}
Returns $true$ if $val$ is an integer.
\subsubsection{\tt{[is-string }$val$\tt{]}}
Returns $true$ if $val$ is a string.
\subsubsection{\tt{[is-list }$val$\tt{]}}
Returns $true$ if $val$ is a list.
\subsubsection{\tt{[is-dictionary }$val$\tt{]}}
Returns $true$ if $val$ is a dictionary.
\subsubsection{\tt{[is-iterator }$val$\tt{]}}
Returns $true$ if $val$ is a iterator.

\subsection{Polymorphic functions}
\subsubsection{\tt{[equals }$val_1$ $val_2$\tt{]}}
Compare $val_1$ to $val_2$ and return $true$ if they are the same, or $nil$ if they are different. $val_1$ and $val_2$ must have the same type, and must either be integers or strings.
\subsubsection{\tt{[is-empty }$val$\tt{]}}
Returns $true$ if a list, dictionary or iterator does not have any elements. Else it returns $nil$.
\subsubsection{\tt{[put }$container$ $position$ $value$\tt{]}}
Store a value into a a list or a dictionary. If it is a list, the $position$ must be an integer i the range $0,1, \cdots, ${\tt{[size }}$container${\tt{]}}$-1$.
If it is a dictionary, the position must be a string or an integer. An entry is deleted from a dictionary by storing $nil$ as the $value$.
\subsubsection{\tt{[get }$container$ $position$\tt{]}}
Retrieve a value from a list or a dictionary. It has the same constraints on $position$ as with \verb|put|. Retrieving an uninitialised entry from a dictionary yields $nil$.
\subsubsection{\tt{[random }$val$\tt{]}}
If $val$ is an integer, return a random number in the range $0,1, \cdots, val -1$. If $val$ is a list, pick a random value from the list.
\subsubsection{\tt{[size }$val$\tt{]}}
Return the length of a string, the number of values in a list, or the number of entries in a dictionary.
\subsubsection{\tt{[< }$val_1$ $val_2$\tt{]}}
Compares $val_1$ with $val_2$. If $val_1$ and $val_2$ are an integers, return $true$ if $val_1$ is strictly less than $val_2$ and otherwise $nil$.
If $val_1$ and $val_2$ are strings, do a lexicographical comparison and return $true$ if $val_1$ comes strictly before $val_2$, and otherwise $nil$.
\subsubsection{\tt{[<= }$num_1$ $num_2$\tt{]}}
Compares $val_1$ with $val_2$. If $val_1$ and $val_2$ are an integers, return $true$ if $val_1$ is less than or equal to $val_2$ and otherwise $nil$.
If $val_1$ and $val_2$ are strings, do a lexicographical comparison and return $true$ if $val_1$ could come before $val_2$, and otherwise $nil$.

\subsection{String functions}
\subsubsection{\tt{[stringjoin }$val_1\cdots val_n$\tt{]}}
Create a string by concatenating $val_1\cdots val_n$.
If $val_i$ is a list, go recursively through the list and join strings occurring within it. Integers are converted to strings during the concatenation. $val_i$ may only be strings, integers, or lists of lists/strings/integers.
\subsubsection{\tt{[substring }$string$ $num_{begin}$ $num_{end}$\tt{]}}
Create a substring from a string, starting inclusively at character position $num_{begin}$ and ending exclusively at character position $num_{end}$. The positions starts counting at $0$, so thus {\tt{[substring }$string$ $0$ \tt{[size }$string$\tt{]]}} is the entire string.

\subsection{List functions}
\subsubsection{\tt{[list }$val_1\cdots val_n$\tt{]}}
Create a new list, containing the elements $val_1\cdots val_n$.

\subsubsection{\tt{[resize }$list$ $num$\tt{]}}
Change the size of the $list$ to be $num$ values. If the new size is larger than the previous, new values are initialised to be nil. The list is returned.

\subsubsection{\tt{[push }$list$ $val$\tt{]}}
Push the value $val$ onto the $list$. The size of the list grows by one, and the last element is now $val$.

\subsubsection{\tt{[pop }$list$\tt{]}}
Remove the last element from the list. The function returns that element, and reduces the size of the list by one.

\subsection{Dictionary functions}
\subsubsection{\tt{[dict }$key_1$  $val_1$ $\cdots$ $key_n$ $val_n$\tt{]}}
Create a new dictionary with $n$ entries, where $key_1$ maps to $val_1$ and so forth.

\subsection{Iterator functions}
\subsubsection{\tt{[keys }$dictionary$\tt{]}}
Create a new iterator across the keys of a dictionary.
\subsubsection{\tt{[values }$container$\tt{]}}
Create a new iterator across the values of either a dictionary or a list.
\subsubsection{\tt{[get-next }$iterator$\tt{]}}
Get the next element from the iterator, or nil if the iterator is empty.

\subsection{Debugging}
\subsubsection{\tt{[log }$string$\tt{]}}
Logs the message from $string$, possibly ignored if debugging is disabled.
\subsubsection{\tt{[assert }$string$ $val$\tt{]}}
Halt the execution with error message $string$ if $val$ is nil, possibly ignored if debugging is disabled.

