\chapter{Language}

In language:
\verb|instanceof|
\verb|typeof|
\verb|<|
\verb|>|
\verb|<=| 
\verb|>=|
\verb|===|
\verb|!==|
\verb|>|
\verb|+|
\verb|-|
\verb|*|
\verb|<<|
\verb|>>|
\verb|>>>|
\verb|!|
\verb$|$
\verb|^|
\verb|~|
\verb|&|
\verb$||$ 
\verb|&&|
\verb|this|
\verb|while|
\verb|if| \verb|else|
string-literals\verb|"...\" \n \t \\..."|
number-literals\verb|0123456789|
array-literals\verb|[]|
object-literals\verb|{}|
identifiers(\verb|A-Za-z_$|...)
function-literals/lambda-expressions(\verb|function(|...\verb|)|)
function-application\verb|()|
method-invocation\verb|()|
subscript\verb|[]|
subscript\verb|.|
\verb|undefined| (written as null)
\verb|true|
\verb|false|
\verb|delete|
\verb|var|
\verb|return|
\verb|this|
\verb|/*|...\verb|*/|
\verb|//|
\verb|;|
\verb|=|
\verb|parseInt|
array.\verb|push|
array.\verb|pop|
array.\verb|length|
array.\verb|join|


\paragraph{Library extensions:}
\verb|iterator|
\verb|div|
\verb|mod|
\verb|assert|
\verb|log|


\paragraph{Possible expansions:}
Math.\verb|max|
Math.\verb|min|
string.\verb|fromCharCode|
string.\verb|charCodeAt(0)|
string.\verb|concat|
string.\verb|slice|
string.\verb|indexOf|
string.\verb|lastIndexOf|
string.\verb|length|
array.\verb|sort|
array.\verb|splice|
array.\verb|unshift|
array.\verb|concat|
array.\verb|reverse|
array.\verb|shift|
array.\verb|slice|
number.\verb|MAX_VALUE|
number.\verb|MIN_VALUE|
*\verb|.toString|
\verb|do|
\verb|for|
\verb|in|
\verb|switch|
\verb|case|
\verb|break|
\verb|default|
\verb|continue|
\verb|eval|
\verb|function|~name\verb|(|...\verb|)|
string.\verb|slice|
string.\verb|split|
string.\verb|toLowerCase|
string.\verb|toUpperCase|

\paragraph{less-likely-expansion:}
simplified-regex\verb|/ /|
\verb|arguments|
\verb|throw|
\verb|try|
\verb|catch|
\verb|finally|
string.\verb|substring|
string.\verb|toLocaleLowerCase|
number.\verb|toLocaleString|
string.\verb|toLocaleUpperCase|
string.\verb|localeCompare|
string.\verb|match|
string.\verb|replace|
string.\verb|search|
\verb|? :|
unary\verb|+|
Date.*
\verb|++|
\verb|--|
\verb|+=|
\verb|-=|
\verb|*=|
\verb$|=$
\verb|&=|
\verb|^=|
\verb|==|
\verb|!=|
\verb|<<=|
\verb|>>=|
\verb|>>>=|


\paragraph{Likely omitted:}
number.\verb|toFixed|
number.\verb|toExponential|
number.\verb|toPrecision|
string.\verb|charAt|
string.\verb|charCodeAt(|n>0\verb|)|
IEEE-754-numbers
automatic-semicolon-insertion\verb|;|
full-regular-expressions\verb|/ /|
Constructor: \verb|Date|, \verb|Object|, \verb|Function|, \verb|Array|, \verb|String|, \verb|Boolean|, \verb|Number|, \verb|RegExp|, \verb|Error|, \verb|EvalError|,\verb|RangeError|,\verb|ReferenceError|,\verb|SyntaxError|,\verb|TypeError|, \verb|URIError|,
\verb|void|
\verb|prototype|
\verb|Math|
\verb|null|
\verb|new|
\verb|parseFloat|
\verb|isNan|
\verb|isFinite|
\verb|decodeURI|
\verb|decodeURIComponent|
\verb|encodeURI|
\verb|encodeURIComponent|
\verb|NaN| \verb|Infinity|
\verb|with|
\verb|/|
\verb|%|
\verb|/=|
\verb|%=|
comma-expression\verb|,|
blocks-anywhere\verb|{}|



\chapter{Being revised/deleted}

\section{Overview}
\subsection{Features}

\begin{itemize}
\item First class functions
\item Object/hashtables
\item Dynamic Arrays
\item Numbers as integers, aritmetic etc.
\item Immutable strings, streams
\item Basic control structures (while, if-else, ...)
\end{itemize}

\subsection{Limitations}
The following features will not be in the first version of the language:
\begin{itemize}
\item Inheritance/prototypes
\item Floating point numbers
\item Exceptions
\item with
\item Random access to characters strings (though sequential access through streams is possible).
\item Regex
\end{itemize}

\section{Types}

\subsection{Undefined}
Undefined is the null type/value.

\subsection{Booleans}
Booleans 

The boolean literals are \verb|true| and \verb|false|.


\subsection{Numbers}

Numbers in MobyScript are at least 32-bit signed integers. 
This allows the language to run on platforms without floating point arithmetics, such as Java CLDC 1.0 and many embedded devices.
Results of overflows are not defined, and may vary between platforms.
Numbers can only entered in decimal notation.

\subsection{Strings}

A string is a sequence of characters, where a character can be any unicode symbol. 


In EcmaScript strings supports random access, and contains unicode characters in range 0...65545.
This makes good sense if implemented as an array of 16-bit numbers. Unfortunately that representation use TODO:fix-spelling:excessive memory and does not support all unicode characters. 
By limiting the string access to be sequential, it is possible to support all unicode characters, while having a more compact format. 
This also makes i possible to add compression later to the strings in memory.
Strings in MobyScript can therefore only be accessed sequentially, for example through iteration.

To simplify parsing, strings can only be quoted with \verb|"|, and the only escape symbols are \verb|\\| and \verb|\"|.

\subsection{Functions}

\subsection{Arrays}

Arrays are numbered sequences of elements.

\subsection{Objects}

Objects are hashtables. 
There is the usual notation for method calls, which requires the method to be a function property of the object.
There are no builtin support for inheritance.


\section{Control structures}

The control structure of the language is \verb|if|, \verb|else|, \verb|while|.

\section{Operators and library functions}

\subsection{Integer operations}

The binary integer operators are
\verb|+|, \verb|-|, \verb|*|, \verb|&|, \verb|^|, \verb$|$, \verb|<<|, \verb|>>| and \verb|>>>|.
The unary integer operators are \verb|-| and \verb|~|.

Integer division is done via the library function \verb|div|. \verb|/| is reserved for floating point division, which is not supported in language version.
Modulus are implemented similarly as \verb|mod| instead of \verb|%|.


\subsection{Iterators}
Iterators are objects, used for iteration. An iterator contains a method \verb|next()| which returns true or false, depending on whether there are more elements, and goes to the next element. The \verb|next()| method also sets the \verb|val| property and possibly the \verb|key| property.

There is a function \verb|iterator(obj)| that creates an iterator across some kind of object. \verb|key| and \verb|val| is not set until \verb|next()| is called. To access all elements in an object or array:
\begin{verbatim}
iter = iterator(object);
while(iter.next()) {
    ... do something with iter.key and iter.val ...
}
\end{verbatim}
To access every character in a string:
\begin{verbatim}
iter = iterator(string);
while(iter.next()) {
    ... do something with iter.val ...
}
\end{verbatim}

The use of iterators is a pattern, which also applies to library routines such as input and output.


\section{Differences from EcmaScript}

MobyScript is a subset of EcmaScript, with some additional library functions, which can easily be defined in EcmaScript. This makes it possible to run MobyScript programs unmodified on every EcmaScript implementation.

--------------

A major difference to EcmaScript is that MobyScript arrays are not objects.

Unlike EcmaScript, inheritance is not supported. This is a tradeof between size and features.
