\documentclass[11pt]{report} 
%\usepackage[paperheight=220mm,paperwidth=170mm]{geometry}
%\usepackage[paperheight=150mm,paperwidth=200mm]{geometry}
%\usepackage{geometry}
\usepackage{a4} 
\usepackage{makeidx}
%\usepackage[danish]{babel} 
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx} 
\usepackage{verbatim} 
\usepackage{fancyhdr}
\usepackage{listings} 
%\usepackage[colorlinks,pagebackref]{hyperref}
\usepackage[colorlinks, linkcolor=black, anchorcolor=black, citecolor=black, menucolor=black, pagecolor=black, urlcolor=black]{hyperref}
%\usepackage{backref}
\usepackage{url}
\frenchspacing
\makeindex
\pagestyle{plain}
\lstset{language=java}
\lstset{escapeinside=`'}
\lstset{basicstyle=\scriptsize}

\title{
Design and Implementation of \\
a Scripting Language \\ 
for Mobile Devices \\
{\scriptsize version \input{version}}}

\author{
  Rasmus Jensen\footnote{
    rasmus@lightscript.net
  }
} 

% Remember 
%    \index terms
%    update template as well as document when structural updates.
\date{2009}

\begin{document}

\maketitle
\renewcommand\abstractname{Abstract}
\begin{abstract}
This thesis creates two new languages: Yolan and LightScript, which run on top of Java Micro Edition and enable scripting on very low-end mobile devices.

The code footprint is the major limitation on low-end mobile devices, and both languages have a significantly smaller code footprint than existing scripting languages. 
The languages are comparable in speed to larger scripting language implementations,
and an order of magnitude faster than most of the benchmarked scripting languages for mobile devices.

Both Yolan and LightScript have first-class functions, dynamic typing, built-in support for hashtables, stacks, etc., and they support interactive programming. They are also able to load and execute scripts presented in source form at run-time. 
The Java Micro Edition does not support dynamic loading of code, so both languages are interpreted.
\index{Java Micro Edition}

Yolan is highly optimised for reducing the size of the implementation code footprint. It has dynamic scope, a Lisp-inspired syntax, and is interpreted by evaluating each node of the syntax tree. 

LightScript is a subset of JavaScript; it has static scoping, and also includes support for closures, objects and exceptions. It is compiled to, and executed on, a stack-based virtual machine. One of things that makes the compact implementation possible is that the LightScript parser is an imperative optimised version of the top-down operator precedence parser.
\index{scope}

Yolan has a code footprint less than half the size of LightScript, and they are similar in speed, even though they have very different evaluation strategies.
Yolan served as a proof of concept and as a stepping-stone toward LightScript. 
LightScript is now a practical language for mobile development and will continue to be developed after this thesis.
\end{abstract}

\renewcommand\abstractname{Resumé}
\begin{abstract}
I dette speciale er der udviklet to nye scriptingsprog til mobiltelefoner: Yolan og LightScript.
De er udviklet i Java Micro Edition, der er den program\-udviklings\-platform, der gør det muligt at køre på flest telefoner.


Sprogene er optimerede med hensyn til størrelsen af det eksekverbare program, da denne er den mest begrænsende faktor på Java Micro Edition.
Sprog\-ene udviklet i dette speciale er mindre end de eksisterende scriptingsprog.
%Størrelsen af det eksekverbare program er den mest begrænsende faktor på Java Micro Edition,
%hvilket .
%hvilket der er taget højde for med sprogene udviklet i dette speciale fylder mindre end eksisterende scriptingsprog.
Udførselshastigheden er på niveau med større scripting\-sprogs\-implementationer
og er betydeligt hurtigere end mange af de eksisterende små scriptingsprog.

Både Yolan og LightScript har funktioner som værdier, har dynamisk typesystem, har indbyggede hashtabeller, stakke, osv., og kan udføre program\-stumper, der indlæses som kildekode under kørslen.
Begge sprog er fortolkede, da Java Micro Edition ikke understøtter indlæsning af ny kode under kørslen.

Yolan er optimeret med henblik på programstørrelsen.
Sproget har dynamisk virtkefelt, Lisp-inspireret syntaks, og det bliver fortolket ved at gennemløbe syn\-taks\-træet og evaluere de enkelte knuder.


LightScript er kompatibelt med en delmængde af JavaScript, hvilket gør sproget lettere at gå i gang med at programmere i for andre. 
Det har statisk virkefelt, understøtter ``closures'', undtagelser og objektorienteret programmering.
Det oversættes til, og udføres på, en stakbaseret virtuel maskine.

Yolan fylder cirka halvt så meget som LightScript, og de er omtrent lige hurtige, til trods for deres forskellige tilgange til programudførsel.
Yolan afdækker mulighederne for scripting\-sprogs\-udvikling indenfor mobiltelefonernes be\-græns\-ninger, og det tjener også som en grundsten for udviklingen af LightScript.
LightScript er et praktisk værktøj til udvikling af software til mobiltelefoner, og det vil fortsat blive videreudviklet efter dette speciale.

\end{abstract}
\setcounter{tocdepth}{1}
\tableofcontents

\chapter{Introduction}

    The topic of the project is to design and implement a scripting language
that runs on very low-end mobile devices. This is both to create a practical tool, and
also a focus for exploration of programming language theory. 

\begin{comment}
The motivation is that a scripting language makes it is easier to make applications for mobile 
devices, and that existing freely available scripting languages
are very limited, slow, or simply does not run on the low-end mobile devices.
\end{comment}

    The educational goals are to learn about programming language design and
implementation, and to learn about programming on mobile devices. Through the
project, I should be able to evaluate and choose programming language features
and implementation techniques, and design and implement a scripting language.

    The focus of the language is that it should be portable, embeddable and have
a low memory footprint. Portable implies that it should run on different devices,
from very low-end mobile phones to high-end computers, possibly also within a web browser. 
Embeddable implies that it should be easy to include within and interface with
other applications. Low memory footprint implies that it should be suitable for
running on platforms where the available memory is measured in kilobytes rather
than megabytes. 

    The approach will be pragmatic and favor simplicity.

\section{Motivation}
\index{Goals}
Scripting languages make it faster to write applications \cite{ousterhout-scripting}:
The type systems allow for more reuse and compared to traditional system programming languages.
They are also more expressive, with more instructions per statement and support for higher level language features such as first-class functions.
In addition, scripting languages open up for code at run-time, allowing user based scripting and scriptable configurations.

On more powerful devices, ranging from high-end smartphones to personal computers, there are very good scripting languages available.
\index{Smartphones}
Scripting language implementations, however, usually take a lot of resources, which is a problem on low-end mobile devices. On those devices, implementations may not be available, may be very slow, or may have limitations, such as not being able to be executed directly, but needing to be compiled on another machine, or they do not have basic data types.
The focus on a better implementation of scripting languages for mobile devices is thus a niche, where the result may actually be of practical use.

The focus on low-end devices also has another benefit:
it broadens the number of devices on which the language may run.
While very low-end devices are becoming uncommon in Denmark,
they still live on in countries with less information technology penetration.
Thus,  by targeting very low-end devices, 
this project may make scripting, and thus easier content creation,
more available,
and that could be the beginning of a stepping stone 
towards more information and computing literacy.
The restrictions of low-end mobile devices also imposes challenges that may lead to interesting solutions.

\begin{comment}
From a personal point of view, 
I would like to get started on development for mobile devices, 
and would also like to brush up on programming language implementation.
Design and implementation of a scripting language for mobile devices is spot on this topic.
\end{comment}


\section{The structure and content of the thesis}

This first chapter is an introduction to the project, defining the method and overall direction. 
The second chapter is a survey of topics related to the projects. This contains the background for decisions on the choice of platform, programming optimisations, language ideas gotten from other languages, and language implementation techniques.
The third and the fourth chapters document two scripting languages developed through this thesis: Yolan and LightScript. These contain design choices for the languages, implementation details, descriptions of the languages themselves, and developer guides for embedding and using the languages.
The fifth chapter benchmarks the developed languages against other scripting languages,
and the sixth and seventh chapters are discussion and conclusion of the work.

The appendices contain the source code for the core Yolan and LightScript classes.

\section{Approach}
\label{method}

When making a project, the approach can be
more or less bottom-up or top-down.
A top-down approach could be like the waterfall model \cite{waterfall} of software development,
where we start with the specification, design and then implementation and test.
The bottom-up approach is characterised by more agile \cite{agile-manifesto} methods, starting out with a quick prototype, which gets more and more refined.

The purpose of this project is to learn about programming languages and mobile development, and create a scripting language. 
The bottom-up approach is chosen, as it opens more up for experimentation, and new ideas are easier to follow, than with the top-down approach.

The methodology of the project was to start out with a series of experimental prototypes related to mobile scripting language implementation, while surveying the field. 
The best parts of the prototypes were then expanded and built further upon, to create the actual scripting language.
Discarded prototypes include a Forth-like language, several parser/compiler implementations on top of EcmaScript, a couple of virtual machines on the JVM, some experiments towards an implementation in C, experiments with mobile applications and their GUI, and drafts of parts of what became Yolan and LightScript.


\chapter{Survey}
\label{survey}
The survey first looks at different mobile platform to motivate the choice of the target platform for the language. 
We choose the Java Micro Edition platform, and section~\ref{j2mesection} then then looks into implementation methods for that platform.
Section~\ref{langsurvey} then surveys other languages related to scripting and low-end devices, and the final section looks into implementation techniques relevant for the scripting language implementation on top of the chosen platform.

\section{Mobile platforms}
\index{Mobile platforms}
This section surveys the different development platforms for mobile devices, to determine a target platform for the language.
Mobile devices ranges from low-end phones, which, if they are programmable at all, only support Java Micro Edition, up to advanced smartphones with performance resources similar to older desktop computers.
\index{Java Micro Edition}

Most low-end phones support some kind of Java midlets.\footnote{A midlet is a small Java application targeting mobile devices, similar to applets, which are small Java applications targeting web browsers}
Here there are various APIs and device profiles, but the basic execution and deployment model is the same for all devices that support midlets.

Low end devices rarely support loading of native code, and higher end devices may require various kinds of code signing to allow native programs to be distributed.

Besides Java and native code, JavaScript is becoming a potential language for applications for high-end phone. \index{EcmaScript}
This is both due to its integration with the web, which means that it is available on the phones with advanced browsers, due to the increased amount of memory on high-end phones
and due to recent major performance advances within the JavaScript implementations, which are propagating towards mobile devices.

\subsection{Embedded systems}
\index{Embedded systems}

%The personal computers, PCs, as we know them, are only a very small fraction of the computers in use.
%Billions of electronic devices nowadays have small embedded computers; they are in mobile phones, kitchen equipment, washing machines, music instruments, car, even advanced greeting cards. 
%These embedded computer systems vary tremendously, from low-end micro controllers with memory measured in bytes, up to powerful CPUs with vector processing units and many megabytes of memory.
%
%\subsubsection{Machine architecture}
%There are two significantly different classes of computers: The Harvard architecture, and the von Neumann architecture. The difference is whether the program code is in the same memory as the data or if they are separated.
%
%Larger computers usually use the von Neumann architecture where program and data are in the same memory, and this is the most commonly known model.
%On small micro controllers on the other hand, the data memory is usually separated from the program memory, which is what is called the Harvard architecture. 
%These two approaches to architecture date back to some of the early computers: the Harvard Mark I \cite{harvard-mark1} and the EDVAC \cite{edvac} by John von Neumann.
%
%On small micro controllers, programs are usually stored in flashable ROM, and on the Harvard architecture the separation of data and code makes it easier and cheaper to build the micro controller. For example, the size of the code words can be independent of the size of the data words.
%These may have less than a kilobyte of RAM, and some kilobytes of possibly flashable ROM for the executable code. Examples of this are the PIC-processors \cite{picspec}, or the ATmega 8-bit microcontrollers \cite{atmegaspec}.
%An interesting operating system for low-end devices is Contiki \cite{contiki}, which also demonstrate how very lightweight threads can be implement.
%
%On more powerful embedded devices, for example mobile phones, and larger computers,
%it may sometimes be practical to be able to work with the code as data, and thus the von Neumann architecture makes more sense there.
%For mobile and larger embedded devices a typical CPU architecture is the ARM \cite{arm-architecture}, which is a 32 bit RISC architecture.
%
%\subsubsection{Development platform}

%While embedded systems are very very common, the software is a shipped, or possibly flashable updateable on larger system, but there are generally no support for software development.
Low- to mid-end mobile phones are embedded devices, where high-end phones are getting closer to being personal computers.
A characterising feature of embedded systems is that the software is shipped with the devices, and there are little or no support for software development.
So while there is support for execution of midlets, native applications are not immediately possible to develop, unless except for the hardware developer.

There are ways to experiment with development for low-end devices nontheless:
Some devices are hackable in the sense that somebody has found out how to upload and customise the firmware, usually without documentation and support from the manufacturer -- examples here range from digital cameras \cite{canonhack}, mobile phones \cite{motorolahack} and handheld gaming devices\cite{nintendodshack}.
A few devices open up for development.

\index{Mindstorm NXT}
An interesting case is the Lego Mindstorm NXT, which has hardware similar to that of very low-end mobile phones, but without sound and GSM. 
The hardware contains an ARM cpu\cite{arm7tdmi}, which is the same as that used in many mobile devices. It runs at 48MHz, and has 256KB of ROM, and 64KB of RAM, plus a coprocessor, a low resolution small display and a couple of buttons. \index{ARM cpu}
This may be used for prototyping an implementation of a scripting language, targeting embedded devices. 



%although this will be postponed until a stable version on top of Java Mobile edition is done.


%So usually access to debug boards and expensive hardware is needed to get experiment with embedded devices, if possible at all.
%Another approach is that some devices is hackable in the sense that somebody has found out how to upload and customise the firmware, usually without documentation and support from the manufacturer -- examples here ranges from digital cameras, mobile phones and handheld gaming devices.
%A case on small embedded devices, where the manufacturer has actually opened up for development is the Lego brick that is a part of the Lego Mindstorm NXT, which will be elaborated in the next section.
%On larger devices it happens more often, though it is still rare: two smartphones \cite{openmoko, htc-android}, an E-book-reader, and some wireless routers and network attached storage \cite{wrtg, nslu, buffalo} have also opened, or partly opened, up for development.
%
%The Lego Mindstorm NXT is interesting because it is an easy to get started with embedded development platform. 
%The main cpu is an ARM7TDMI \cite{arm7tdmi}, which is commonly used in mobile phones, and also in many other embedded devices. 
%It is clocked at 48MHz, and is attached to 256 KB of flashable ROM and 64 KB of RAM, which means that it is low-end, compared to mobile phones, while powerful viewed as an embedded device.
%There is also an ATmega48 \cite{atmega48} 8-bit coprocessor, which has 4KB of flashable ROM and 512 bytes of RAM, which is a typical microcontroller. 
%The coprocessor usually reads sensors, controls motors, and can power the main cpu down, to reduce power usage.
%The system also have a 100x64 black/white lcd display, and a couple of buttons, so it has a lot of potential as a development substitute platform for low-end mobile devices, which do not allow 3rd party firmware.
%
%So while there are no low-end mobile phone which opens up for development, the Mindstorm NXT has similar specs, and can thus be a prototype target for an implementation targeting this class of devices.

\subsection{The J2ME / Java Micro Edition}
\index{Java Micro Edition}
\index{J2ME|see{Java Micro Edition}}

J2ME (Java Micro Edition\footnote{Java Micro Edition is a recent rebranding of J2ME}) is the most common platform for mobile applications, supported by more than a billion devices \cite{sun-j2me}. 
Two thirds of mobile phones shipped today supports Java \cite{esmertec-globenews}. 
\index{Mobile platforms!marketshares}
%http://www.globenewswire.com/newsroom/news.html?d=149713
Most mobile devices either require strict code signing, or do not allow native applications to be loaded at all, implying that J2ME is often the only option for mobile application development.
J2ME is a trimmed down Java Virtual Machine (JVM) so it has most of the features and limitations of a standard Java JVM.
It is a heterogenous platform:
there are different APIs/extensions from different vendors, and different device profiles for different hardware capabilities, meaning that the applications need to be ported.

Applications for J2ME, are called Midlets and are distributed via JAR-files (Java ARchive). A JAR file is essentially a zip file containing the compiled Java classes, data files, and some meta information.

J2ME has two device configurations CLDC 1.0 (Compact Limited Device Configuration 1.0) \cite{cldc10}  and CLDC 1.1  \cite{cldc11}. The major difference between the two is that CLDC 1.0 is integer only, whereas CLDC 1.1 supports floating point numbers.
Approximately $\frac{1}{6}$ of the mobile phones that support J2ME are limited to CLDC 1.0, whereas CLDC 1.1 is supported by the remaining $\frac{5}{6}$ of the phones \cite{mobref}.
% http://stats.getjar.com/statistics/world/gJavaCLDCVer
A limitation of both CLDCs is that they do not support reflection nor dynamic code loading.
The lack of a reflection API implies that a scripting language implementation cannot discover native functions itself. This means that foreign function interface between Java and a scripting language, cannot discover or work with Java dynamically, but Java functions that should be callable from the scripting language must be coded into the implementation before deployment.
The lack of run-time class loading means that JIT compiling to the JVM is not possible.
Nor is native code available, so the only way to execute scripts loaded at run-time is through interpretation, possibly via a virtual machine.

The CLDCs are based upon the Java JVM \cite{jvmref} with some instructions removed, and some metadata added to ensure stack discipline. 
In order to simplify the J2ME JVM implementation, Java class files have to be preverified, before they can be loaded.
The preverification adds meta data about stack use, and removes certain instructions, such as local jump-and-save-register, to make it easier to implement a JVM that is safe against malicious code trying to overflow the stack.
The reference implementation of CLDC 1.0, KVM, is a switch-based interpreter with a compacting mark-and-sweep garbage collector \cite{kvm}.

The JVM limits interpreter implementation: it does not support label references as values, nor does it support functions as values. This makes some of the optimisations discussed in 
Section~\ref{interpreter-implementation} impossible.
Instead, it does have a built in switch opcode as well as support for method-dispatch based on the type of an object, so an interpreter could be switch-based, or have a class for every opcode.

The resources available for J2ME applications on mobile phones start at 64KB for the size of the JAR-file and 200KB for the run-time memory on the lowest end devices \cite{nokia-optim}.
These numbers are for the full application, so the resources available for an embeddable scripting language could be significantly less than this, depending on the resource usage of the application in which the scripting language is embedded.

As Java Micro Edition is the most widespread platform for mobile devices, this will be the target platform for the scripting language during the thesis.

\subsection{Smartphones}
\index{Smartphones}
Many high-end phones -- smartphones --  allow loading of native code. 
This covers approximately 12\% of the mobile phone market measured in number of units.\footnote{In the fourth quarter of 2008 38.1 million smartphones where sold \cite{gartner}, whereas the total number of mobile phones sold in the same period were 314.7 million devices \cite{cellular-news}.}
\index{Mobile platforms!marketshares}
% http://www.cellular-news.com/story/36315.php
Smartphone development platforms give more access to the devices than J2ME, but they are at the same time more difficult to develop for, due to the large number of platforms and limits on distribution due to requirement on cryptographic signing of code.

The main operating systems for smartphones are: Symbian, RIM, Windows Mobile, Mac OS X and Linux, which are very different operating systems, and on top of the operating system, different phones also have different user interfaces and programming models.
Development is not only possible as native applications, but many of the devices also support J2ME or other Java implementations, and on those devices that include a modern web browser, JavaScript is also a possible target for application development.
If the scripting language is implemented on top of Java, then it will also run on many smartphones.  It is important to note, however, that some devices only support Java dialects other than Java Micro Edition, so that should be kept in mind when developing the language. In addition, if the developed scripting language is a subset of JavaScript, it will already have an implementation deployed on those devices with advanced browsers.

%\subsubsection{Symbian}
%
%Symbian is the classical operating system for smartphones. Applications are usually written in C/C++, with some restrictions to allow it to run better on with a moderately small amount memory. 
%In order to distribute native applications on Symbian, it has to be cryptographically signed \cite{symbiansigned}.
%Symbian is a currently closed source, but is on its way to be released as open source \cite{symbianopensource}.
%
%It is the most popular operating system for smartphones, having 47.1\% of the market \cite{gartner-phone-survey-2008q4}. There are different incompatible user interfaces on top of Symbian, e.g. UIQ, QT, S60. 
%
%\subsubsection{RIM, Windows Mobile and Mac OS X}
%
%RIM (Research In Motion), Microsoft Windows Mobile and Mac OS X are the second to fourth most popular smartphone operating system, with 19.5\%, 12.4\% and 10.7\% market share respectively \cite{gartner-phone-survey-2008q4}.
%RIM is connected with the BlackBerry devices, Mac OS X is connected with the iPhone, and Windows Mobile covers different hardware vendors. 
%All these system are properitary closed source.
%
%\subsubsection{Linux}
%
%Linux has 8.4\% of the market share of smartphone operating systems.
%While most of these are properitary systems, two promising initiatives are opening up, wnad while they do not any significant market share yet, they are interesting from a developer point of view, and described below. These are the Android platform and the Openmoko project.
%
%
%\paragraph{Android}
%
%Android is a software stack for smartphones. It is open source, and driven forward by google.
%It is build upon a linux kernel, but user applications are not distributed natively, but executed on the Dalvik vm. Applications are written in Java, which is then compiled to Dalvik vm, rather than the usual JVM. The motivation for this is both to overcome some of the shortcomings of the JVM on mobile devices, and possibly also some cooperate issues with ownership of JVM technology.
%Besides supporting Dalvik applications, there is also a modern webbrowser -- a WebKit derivative -- meaning that JavaScript can also be executed on the device.
%
%While the software stack itself is open source, it also allows the manufactorer to make and keep proparitary changes for themselves. 
%Meaning that actual phones designed with the stack -- at least those currently on the market -- are not truely open, in the sense that thay contain properitery drivers and special developer-versions of the phones are needed if you want to be able to load customised operating system images/native code.
%
%Android is of course being ported to the devices from the Openmoko project, and in that case it is of course truely open.
%
%\paragraph{Openmoko}
%Openmoko is a project towards having open source phones.
%It is both a software stack for smartphones, and it is also a small development division of the hardware company FIC, where they are making the first open source phones.
%The two phones released so far have lots of rough edges both software and hardware wise, but from a developer point of view, these very interesting as they are not just phones but full Linux computers with X11 and most things as known from larger scale Linux environments -- and the source code is available for everything, so it is even possible to write new operating systems for them, and customise them in every way.
%
%

\section{Optimising Java for low-end mobile devices}
\label{j2mesection}
The next two sections look into methods of reducing the memory usage and code footprint of Java midlets.
Memory usage and code footprint are very limited resources on some mobile devices, especially the code footprint, and techniques for optimising these will be needed when implementing the language.

\subsection{Reducing the memory usage of J2ME applications}

Some devices only have little memory available,
and an optimisation here is to be able to avoid having memory intensive parts of the program run at the same time. For example, with a scripting language, it is desirable to be able to garbage collect the executed parts of a long script when they are done, so that the memory becomes available for other computations.
The usual size optimisations, such as finding compact representations, trimming dynamic data structures, avoiding sparse data, etc., are also applicable.
There may be a tradeoff between the code footprint and run-time memory, as compact representations and other optimisations may require more code to be implemented.

\subsection{Reducing the footprint of J2ME applications}
Some optimisations to reduce the code or JAR-file footprint:
\begin{itemize}
\item Reduce the number of class-files.
\item Write initialisation manually, where the automatically generated initialisation is inefficient.
\item Use a JAR-optimiser/obscurifier.
\item Put the classes in the unnamed package.
\end{itemize}

Another optimisation is to reduce the number of classes \cite{nokia-optim, kahlua-thesis}.
This may reduce the size of the JAR file significantly,
even though it does not change the amount of code:
Each class file has its own symbol table, which means that if classes are merged, then common symbols only need to be represented once, rather than once for each class.
Furthermore JAR files are essentially zip-archives, and each file in a zip archive is compressed individually \cite{zipspec}, which means that small files typically get compressed less than larger ones, due to the small compression context.
The downside of reducing the number of classes is that it could go against the object-oriented design, and the implementation of the scripting language may become more difficult to read and edit. 

Initial values are not supported directly by the Java class file format, but instead
JVM-code is generated, that does the initialisation. 
This code is often inefficient. For example the initialisation:
\begin{verbatim}
byte[] bytes = { 1, 4, 3, 4, 5, 6, 2, 3, 1 } ;
\end{verbatim}
generates code corresponding to
\begin{verbatim}
byte[] bytes = new byte[9];
bytes[0] = 1; bytes[1] = 4; bytes[2] = 3;
bytes[3] = 4; bytes[4] = 5; bytes[5] = 6;
bytes[6] = 2; bytes[7] = 3; bytes[8] = 1;
\end{verbatim}
which for a larger initialisation is significantly more expensive than the following manually written initialiser:
\begin{verbatim}
byte[] bytes = "\001\u004\u003\u004\u005\u006\u002\u003\u001".getBytes();
\end{verbatim}

Another thing to be aware of is that strings in Java class files are encoded such that only characters with unicode values between 1 and 127 (inclusive) use one byte per character. 
Binary data, which use the entire range in a byte (0-255), may therefor uses several bytes per byte if encoded as strings, and it may therefore make sense to place larger binary data objects, in external files, rather than within the class file.

JAR file optimisation/obfuscation can reduce code footprint because it may
remove unused code,
rename methods and classes, such that they use less space in the symbol table,
make \verb|static const|s work as \verb|#define|s,
 and optimise the code, thus shortening it.
This also allows one to write more readable code with less concern for the code footprint, knowing that some of the more verbose parts will be optimised away.

Using the unnamed package saves space in the symbol table, as class references become shorter.

The code footprint limit may be tighter that the run-time memory limit, and it may be possible to partition the execution such that different parts of the application do not need to use run-time memory at the same time.
Therefore, in this project with the design of an embedded scripting language, the code footprint will have slightly higher priority than the run-time memory usage, although both are important.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Programming Languages}
\label{langsurvey}
The following sections survey some exixting programming languages that have served as inspiration for this project:
\begin{itemize}
\item Forth is surveyed as it runs on very minimalistic systems, and it is also a stack-based language, thus relevant for the design of virtual machines. 
\item Hecl is the major scripting language for mobile devices
\item JavaScript is the basis of the LightScript language implemented in this thesis.
\item Lua has a focus on embedded devices, and solutions from their implementation can inspire the languages created in this thesis. There is also an implementation of the Lua virtual machine targeting mobile devices, which is why this language is also related to the benchmarks presented later on.
\item Python is becoming relevant on mobile devices, as it runs on many smartphones. Some of its language features may be usable in the design of new languages.
\item Lisp and Scheme are some of the inspirations for Yolan, especially with regard to the syntax. 
\item Self is highly relevant for the LightScript implementation, as LightScript's object system is based on this, via JavaScript.
\end{itemize}


\subsection{Forth and other stack-based languages}
\index{Forth}
Forth is a stack-based language.
It is very interesting for this project, as it is an example of an interpreted minimalistic language running on even very low-end devices.

The syntax of Forth is different from that of most modern languages, due to the use of reverse polish notation.
Functions work on a stack, which the programmer is explicitly aware of. 
Functions replace their arguments on the top of the stack with the result. 
Besides the stack for arguments, there is also a stack for return addresses.
%New words/functions can be defined, and are concatenative in the sense that functions written after each other have the same semantics as function bodies themselves written after each other.

%Forth looks very strange when starting looking at the programs, but it seems like it is the question of getting habit of being aware of the stack.
%The programming style is focused on decompositions. 
Forth supports meta programming.
Forth systems have explicit compilation, the system has two modes: compile mode and interpret mode. 
It is possible to create words that are executed at compile time, using the immediate keyword.
Words -- ``functions'' in Forth -- are first-class data types.

An introduction to Forth is
``Thinking Forth'' \cite{thinking-forth} which covers, not only Forth programming, but it also touches a lot programming and problem solving in general. This include details on implementation of stack-based languages.
There is also a tutorial Forth implementation \cite{jones-forth}, that shows how Forth, and thereby stack machines, can be implemented. 

\index{Virtual machine}
Forth is also interesting from the virtual machine point of view, as it is similar to the machine code of a stack-based virtual machines. So Forth implementation techniques share a lot with those of virtual machines. And research within this topic overlaps, an example is a dissertation on implementation of stack languages on register-based machine \cite{ertl-dissertation}, which uses Forth as the representative stack-based language.

Other more recent stack languages are Joy, Cat, and Factor \cite{factor-language}.
Interesting developments here are stronger typing, and also the use of anonymous code blocks to create the control structure.
The idea of the anonymous code block is an inspiration for the Yolan scripting language developed in this thesis, as the concept of delayed computation is somewhat similar.


\subsection{Hecl and Tcl}
\index{Hecl}
\index{Tcl}
Hecl is relevant to investigate, because it seems to be the major mobile scripting language. 
It is a dialect of Tcl (Tool Command Language), which is an embeddable scripting language \cite{tclbook} with a prefix notation, i.e. the syntax is similar to Logo, -- and also similar to Lisp if we see each unquoted line-break as an end+begin parenthesis.
Comparisons and mathematical expressions need to be written lisp-like in Hecl, whereas Tcl has an \verb|expr| function, that evaluate an expression taking care of operator precedence etc.
This indicate that a simple syntax need not be a hindrance for scripting languages on mobile platforms.
The documentation and online materials seems well rounded, which may be a factor to it popularity.



\subsection{JavaScript/EcmaScript}
\label{JavaScript}
\index{EcmaScript}
JavaScript was created as a scripting language for web browsers, and was later standardised under the name of EcmaScript \cite{ecma-262}.
The reason it has become interesting is that it is included within most web browsers, and is thereby one of the most widely available platforms.

JavaScript is a dynamically typed scripting language with closures / first-class functions, and a prototype-based object system, similar to Self.
While it has expressive features, it is also a very mainstream language, both through its presence within the web and its C-like syntax, and thus making it possibly less intimidating for new programmers.
\index{Closure}

JavaScript is very relevant for this thesis, as the LightScript language developed here, is a subset of JavaScript/EcmaScript, for several reasons: 
It already exists as a platform meaning that the new scripting language already has virtual machines deployed. As the EcmaScript syntax is known, or at least recognisable for many developers, even web-``developers'' and users, it may be easier for them to transition, or start using the new scripting language on mobile devices. 
EcmaScript supports closures and first-class functions, which can thus be included in LightScript without breaking compatibility.

An issue with EcmaScript is that it has some unfortunate design decisions \cite{crockford-web}, which will be elaborated on in Section~\ref{lightscript-design}.

%The following sections look at the implementation of EcmaScript and also at EcmaScript on mobile devices. 
%Implementation techniques from those, as well as existing works, may be relevant as one of the scripting languages developed in this thesis is a subset of EcmaScript.
%At the same time, the language was developed in a hurry, also leading to some less fortunate design choices
%A good introduction to JavaScript is given in the book ``JavaScript the good parts'' \cite{goodparts} and some of its material is also available online which serves well as an overview of the language. The EcmaScript standard \cite{ecma-262} can be used for getting to know the details of the languages.

The following paragraphs describes the main open source implementations of Java\-Script/EcmaScript.

\paragraph{JavaScriptCore} 
\index{JavaScriptCore}
JavaScriptCore \cite{webkit-src} is the implementation of JavaScript in Webkit.
The latest version is called SquirrelFish and is an optimised register-based virtual machine,
where support for JIT compilation is also being developed.

\index{SquirrelFish}
The engine has been optimised a lot within the last year 
\cite{squirrelfish-bench}: the earlier versions were performing evaluation by walking through the abstract syntax tree, and were at that time similar in performance to SpiderMonkey JavaScript implementation.
The new version -- SquirrelFish -- is much faster, which means that it is similar in performance to TraceMonkey and V8 JavaScript implementations.

\paragraph{QScript}
\index{QScript}
QScript \cite{qt} is the EcmaScript implementation that is a part of QT.\footnote{QT is a programming API and cross platform graphical toolkit. It is the base for KDE (the K Desktop Environment) as well as the GUI for several Motorola mobile phones. It was recently acquired by Nokia, who has released it under the LGPL licences, and is making it a part of their Symbian platform.} This implementation is targeting application scripting rather that web scripting. An interesting part of QScript is its support for generation of bindings to native functions. As WebKit is being integrated with QT, QScript is likely to be replaced with or merged with the WebKit scripting engine in the long run.

\paragraph{Rhino}
\index{Rhino}
Rhino \cite{rhino} is an implementation of JavaScript on top of Java. The implementation is mainly used as an embedded language for Java applications. The implementation transforms the JavaScript program to Java classes, which are then executed.

\paragraph{SpiderMonkey}
\label{spidermonkey}
\index{SpiderMonkey}
SpiderMonkey \cite{spidermonkey} is the JavaScript engine in Mozilla's browsers, and is also usable as an embeddable engine in other applications. Execution is based on a virtual machine, which either has a switch-based dispatch or direct threading, depending on what the compiler supports.

\paragraph{TraceMonkey} 
TraceMonkey \cite{tracemonkey} is a branch of SpiderMonkey, which incooperates JIT compilation, with a JIT compiler based on trace trees \cite{trace-tree, trace-tree2}, 
\index{TraceMonkey}
which, rather than JIT-compiling the entire program,
traces and then compiles the most executed paths through the program.
This means that the JIT compiled code gets optimised to the actual execution,
and less code needed to be compiled.

\paragraph{V8} V8 \cite{v8} is a JavaScript implementation made by Google, and released in 2008 in conjunction with the release of their browser ``Chrome''. 
\index{v8}
While it is not directly connected with the Android platform, a JIT compiler is already in place targeting the ARM CPU, so it seems likely that it will also target mobile devices in the long term.

A main focus and benefit of V8 is high execution speed.
%The design builds upon experience from Self/Smalltalk implementations \cite{articles-before-v8}.
It is designed for JIT compilation from the beginning, and it also does some class inference to optimise methods and property accesses.
Specifically, whenever a property is added to a JavaScript object this creates an implicit class. When code is JIT'ed, a property access is compiled to a type check followed by fast code for accessesing the property, similar to that of more static, class based languages. This is possible due to the type check and implicit class, and it is much faster than a traditional JavaScript object property lookup.

The garbage collector is fast, - it is a generational garbage collector with two generations. The young generation is collected with a copy-collector which is linear in the amount of live data, and thus heap allocation of activation records is almost free. 
This is combined with a mark and sweep collector when a full collection is needed.

\subsubsection{Targeting mobile devices}

During the writing of this thesis, it has turned out that there are other projects working on JavaScript languages for mobile devices.

There is a standardised EcmaScript Mobile Profile, which removes some features from the language, but is not implementable in practice on top of CLDC 1.0 as it still relies on floating point numbers.

\index{EcmaScript!Mojax}
Mojax (Mobile Ajax) \cite{mojax} is a properitary virtual machine for an EcmaScript-like language. The language is also a subset of of EcmaScript, integer only, and appears not to support exceptions nor regular expressions.
The Mojax implementation appears to be a virtual machine that cannot execute scripts directly, but they need to be compiled before they can be loaded.

\index{EcmaScript!Mbedthis}
There is a closed source implementation of a subset of JavaScript, that targets embedded devices, written in C, and developed by Mbedthis \cite{mbedthis}. It uses integers and does not have exceptions, labelled statements, switch, while, do-while, regular expressions, function literals, object literals, array literals, prototypes nor class methods.
% http://www.embedthis.com/products/appweb/doc/guide/appweb/users/ejs/overview.html
Recently that implementation seems to have been abandoned, in favor of a new, more compliant implementation: Ejscript \cite{ejscript}.
%http://www.ejscript.org/products/ejs/index.html
A C based implementation is available under the GPL, there is apparently a J2ME implemention that is not published yet.
\index{EcmaScript!Ejscript}

\subsection{Lua}
\index{Lua}
Lua is the language that comes closet to the goals of this project: it is a scripting language with first-class functions that runs on embedded and mobile devices.
In addition, it is a dynamically typed, statically scoped embeddable scripting language, which is characterized by only having one data structure: associative tables.
It has both good performance and a relatively low code footprint.

On mobile devices there is an implementation of the Lua virtual machine called Kahlua \cite{kahlua}.
It is only a virtual machine, meaning that the Lua scripts need to be compiled on another platform, before they can be loaded and executed.

\subsection{Python}
As phones are becoming more powerful, Python is beginning to play a role as a mobile scripting language on high-end devices. This is probably due to that Pythin is already a popular and major scripting language on computer platforms.

Python has some nice features, that may be inspiring when implementing other languages. Comments/documentation are integrated in the language via the concept of docstrings, which are a special kind of comment that is also available for inspection during runtime. Unit testing is also integrated within the documentation framework, where a special syntax indicates that code in the documentation can also be executed when running tests.
Required indentation leads to more easily readable programs.

The issue with Python on mobile devices is that its implementation is relatively resource intensive, and it is thus currently only available on high-end phones.

\subsection{Scheme and Lisp}
\index{Lisp and Scheme}
Scheme and Lisp are especially interesting, due to their minimalism, which is inspiring in the design of a language with strong restrictions on the implementation environment.
The syntax is mostly isomorphic with the abstract syntax tree, meaning that parsing is mostly trivial.

Early versions of JScheme\cite{norvig-jscheme} have code footprints that are small enough for mobile devices, but would need to be ported, as they use reflection that is not available on mobile devices.
JScheme is interesting as a benchmarking target, as it is a high level language with a small footprint.

%Another Scheme implementation, which targets mobile devices is ULM (Un Langage pour la Mobilité) which is a part of a thesis on agent systems \cite{ulm}. Essentially the implementation is a virtual machine, which runs as a backend of a modified version of the Bigloo \cite{bigloo} Scheme compiler.
%This was considered as a potential benchmark target, but I did not have time to get it to run, due to issues with dependencies, and at the same time it has a relatively large code footprint -- 96KB.

\subsection{Self}
\index{Self}
\index{Prototypical inheritance}
\label{survey-self}
Self \cite{self} is in particular interesting due to the prototypical inheritance, that is the object model of EcmaScript and thus also LightScript.
Traditional object oriented programming, is designed around classes and objects, where classes can inherit from other classes, and objects instantiate classes.
Instead of classes and subclasses for inheritance, Self has a clone operator, which creates a new object using an existing object as blueprint.
An object in Self contains a pointer to the parent (cloned) object, and a mapping from property names to values or methods. When a property is read, the mapping of the current object is first searched, and if the name is not found there, then the parent objects are searched for the property.

\section{Interpreter implementation}
\label{interpreter-implementation}

As we are building on top of Java, 
several interpreter implementation issues
become less relevant:
\begin{itemize}
\item On JVM platform, the dispatch can only be implemented 
with a switch statement or be based on class types. The
latter is much more expensive, spacewise, and therefore not applicable.
Threaded dispatch, and other faster dispatch methods are not possible
due to lack of support for using pointers to code.
\item With regard to garbage collection, we can piggyback on the garbage collector from the JVM, which reduces the code footprint as we do not need to implement one ourselves. This has the issue that we can not rely on how it is implemented, meaning that the use of heap allocated activation records may be less of an option, as it is stongly affected by the performance of the garbage collector.
\item JIT compilation to native code, or targeting the JVM, is not possible as dynamic loading of code is not supported at all on most Java Micro Edition implementations.
\end{itemize}

The next section looks at register vs. stack virtual machines, which is an important aspect at the design of virtual machines. This is followed by a look at parsing, more specifically top-down operator precedence parsing as this has low code footprint, which is important in our context. And finally we consider the issue of  scope and the implementation of variables.

%as the embedded-C implementation of the language was not finished, this part does not belong in the thesis, but should be removed, and possibly make it into later documents. Keep note about using switch due to JVM, which is suboptimal compared to what can be done on a native machine.
%... jvm only switch based or class based, which is suboptimal

%as the embedded-C implementation of the language was not finished, this part does not belong in the thesis, but should be removed, and possibly make it into later documents. Replace note about piggy-backing on the JVM GC, which is unlikely to be generational, which means that heap allocated stack will be expensive.
%... heap allocated stack frames and generational GC.
%The KVM, which is the reference implementation for mobile Java Virtual Machines, is now using a compacting mark and sweep. It originally started out with a copying collector, which had a larger memory requirement. And subsequently it used a non-compacting mark and sweep, where compaction were later added.


%This section looks into different aspects of interpreter implementation.
%First, is a discussion on different types of virtual machines, namely register and stack machines, and their different benefits and tradeoffs. 
%Then, there is a discussion on the implementation of dispatch, which is one of the bottlenecks of intepreters.
%Third, there is a discussion of garbage collection techniques.
%And finally there is a discussion on different approaches to managing run-time stack.

\subsection{Stack and register based virtual machines}
Virtual machines are usually either stack-based or register-based.

A stack-based virtual machine operates similar to the language Forth, where all operations work on the top of the stack. 
Operands are implicitly coded, such that for example the add instruction just pops the top two elements of the stack, and pushes the sum. 
Stack machines are easy to compile to, 
which can simply be done by emitting the opcodes of a post-order walk through of the abstract syntax tree. 
There are no issues of register allocation, spilling, etc.
Stack machines are commonly used, the best known example being the Java Virtual Machine, and there are many other languages that turn out to be implemented on stack machines when looking under the hood, for example: Python, the SpiderMonkey JavaScript implementation, and the .NET Common Intermediate Language.

Register-based virtual machines are becoming more common. 
Usually they have a high number of registers, leading to longer opcodes than stack-based virtual machines. But on the other hand, they have fewer opcode per program, leading to faster execution \cite{register-vs-stack1, register-vs-stack2}. 
Examples of register-based virtual machines are the Dalvik \cite{dalvik-vm} virtual machine, LLVM \cite{llvm}, Parrot \cite{parrot}, and the virtual machine of Lua 5.0 \cite{lua-vm}.

A third approach to implementing a virtual machine is just to use the abstract syntax tree for evaluation. This was for example used in earlier versions of WebKits JavaScript implementation, but has now been superseded by a stack-based virtual machine, which is currently being replaced by JIT compilation.

\subsection{Parsing}
A language implementation must parse the source text into the abstract syntax tree that is manipulated by the rest of the compiler.

Parsers often take quite a large amount of code, especially if they are generated by compiler-compilers.
Generated lexers and LALR(1) parsers usually have quite large state tables.
Recursive descent parsers seem to use a bit less code footprint that LALR parsers, but still require functions for all the grammar productions, which still takes quite a bit of space..
Grammar-based parser generation and implementation have been extensively studied and will not be discussed further.

Another approach, which is also very elegant, 
but has recieved less attention is the
top-down operator precedence parser.
This kind of parser has the benefit of a low code footprint,
partly due to genericity of the parser code,
for example: only one parsing
function for the left associative infix operators,
one function for the right associative infix operators,
one function is needed for prefix operators, etc.
So a top-down operator precedence parser will be used for parsing in LightScript.

\subsubsection{Top-down operator precedence parsers}
\label{tdop}
Top-down operator precedence parsing combines recursive descent parsing with operator precedence, which simplifies the implementation significantly.
It was first described thirty years ago \cite{top-down-operator-precedence}, but has not received much attention until lately \cite{beautiful-code, crockford-jslint}.


A token may have two functions and a precedence, which are used to build the syntax tree when the token is encountered.
If the token stands first (is leftmost) in an expression, and the null denominator function is use to build the abstract syntax tree node..
The second function is the left denominator function is used to build the abstract syntax tree node, if we already have something to the left of the token within the expression.
The precedence of the next token is used to determine whether we have finished parsing an expression or need to use the token to build another abstract syntax tree node by calling left denominator function of the token.

To be able to build the abstract syntax tree node, the left denominator function takes an argument, which is the parsed node to the left of the token. Additionally it is possible for the denominator functions to parse expressions to the right of the token by calling the parsing function recursively. Here it is necessary that the parsing function also take a priority as a parameter. This priority parameter ensures that the left denominator functions are not called for tokens with lower priority.

The parsing itself is then simply done by first calling the null denominator function of the first token, and then calling the left denominator functions of the next tokens, as long as the next token has higher priority than the priority passed to the parsing function.
The denominator functions attached to each token are then responsible for building the syntax tree.
So the core loop of the parser is implemented as follows:
\begin{verbatim}
define parse(int priority):
    syntax_tree = next_token.null_denominator()
    while next_token.priority > priority:
        syntax_tree = next_token.left_denominator(syntax_tree)
    return syntax_tree
\end{verbatim}

Now we need to assign meaningful precedence and denominator functions to the tokens:
Atoms, variable names, literals etc., have a null denominator function that returns their node. Unary operations such as minus, not, etc., have a null denominator function that calls parse once and creates a node that applies the operator to the parsed node.
Binary (infix) operators have a left denominator function that creates a node with its parameter as the left hand side and calls parse to construct the right hand side. Binary operators can be made right associative by passing a priority to parse, that is one less than the priority of the operator itself.
The parsing of lists calls parse until the end of the list is reached. Other constructions can be implemented similarly. 

The limitation of this parser as described here is that only one left-hand side expression is passed to the left denominator function, making reverse polish notation languages difficult to implement. A non-recursive version with an explicit stack could solve that.

\subsection{Scope}
\label{survey-scope}
\index{Scope}
Defining the scope of variable declarations  is important when designing a programming language.
There are two major kind of scopes: static scoping and dynamic scoping.
Static scoping is also called lexical scoping, and corresponds to the lexical structure of the source code.
This is in contrast to dynamic scoping, where variables are accessible other places than in the blocks where they are defined. 
The difference between dynamic and static scoping is exemplified by the following:
\begin{verbatim}
function f() {
    x := 17
}
function g(x) {
    f()
    print(x)
}
g(42)
\end{verbatim}
which would print 42 in a statically scoped language, and would print 17 in a dynamically scoped language.

Static scoping is more natural as the scope matches the structure of the code. Dynamic scoping requires more discipline, as it allows the programmer to tamper with local variables of other parts of the code, and counters good habits of information hiding. A very important feature is also that static scoping can be used to create closures for functions, which gives extra flexibility to the language.
\index{Closure}
On the other hand, dynamic scoping can simply be implemented by a global mapping from name to value, and can thus use slightly less space in the code footprint. 
Dynamic scoping also does not suffer from the funarg problem discussed in Section~\ref{funarg}.
For more advanced language implementations static scoping has the benefit over dynamic scoping that code is easier to analyse and optimise due to locality, in the sense that the use of variables is limited to the local lexical scope.

\subsubsection{Stacks and activation records}
A typical way to implement local variables is by using a stack.
In this section, we assume that we are on a full stack machine; 
in practical implementations on CPUs, the top of the stack is usually implemented in a number of registers instead.

Whenever a function is called, the arguments are pushed onto the stack. Then, when the function is entered, a return pointer is often pushed onto the same stack, and space is allocated for the local variables. The computation is then done, and the function returns, jumping back to the call site and restoring the stack size to the original.
The allocation on the stack allows for local variables, and functions can also be recursive. The part of the stack containing the local variables, etc., is called the activation record for the function.

\subsubsection{Scope and first-class functions}

When we have first-class functions and static scoping, we cannot just place the activation records on the stack. When functions are nested, inner functions may live on, and access local variables of the outer function, after the outer function has returned. Consider the following code:
\begin{verbatim}
function f(x) {
    function g(y) {
        return x + y
    }
    return g
}
\end{verbatim}

In this code the function $g$ lives on after $f$ has returned, and at the same time $g$ uses a value that lies in the activation record of $f$. Therefore, if the activation record is allocated on the call stack, and nothing further is done about it, the value of $x$ will no longer be available when $g$ is called.
This is an example of the ``funarg problem'', which is the problem with scoping when a function is given as an argument or returned.
\label{funarg}

There are several solutions to this problem:
\begin{itemize}
\item Disallow/not support first-order nested functions or access to outer scope within nested functions. Or not having static scope.
\item Disallow scope variables to be changed from the inner scope. Instead such variables are passed as immutable values at function/scope creation. 
\item Allocate the activation records on the heap, instead of on the stack, and let them be garbage collected. 
\item Keep track of which variables may live on after the function exits, and move those to the heap.
\end{itemize}

Not having nested functions, only having a single-function-local and a global scope, or not having static scope, simplifies the implementation and is a solution often taken in mostly imperative languages.
%This solves the issue, but at the same time it also removes support for closures.
\index{Closure}

Copying the values of outer scope variables to an inner scope is possible in a purely functional language, as variables are not mutated. If the language is not purely functional, when a variable is mutated in an inner function, it is only the copy that is mutated, and the mutation is local to the function.
A workaround for mutations in languages that copy variables from outer to inner scope is to use a reference to the mutated variable rather than the variable itself, such that when the reference is copied to the inner scope it is still possible to mutate the value, as we need not mutate the reference itself.
Another approach is to let the outer scope stay alive until the inner closure dies, and then just reference variables as usual.
This can be done by allocating the activation records on a garbage-collected heap,
which is not as expensive as it may seem, due to the high effiency of modern garbage collectors.
Another approach is to keep track of which variables may stay alive at the exit of a function, and move them to the heap at that time.
Or just identify variables that are used by in inner functions, and put those on the heap.

%\subsubsection{Implementation of variables}
%When the scope is implemented, an issue is how to implement the variables. 
%Here are several options: 
%
%The  classical good-performing approach is to implement them on a stack. On each function call, an activation record is added on a linear stack, and each of the variables can be spilled into its place on the activation record. This is very fast, as allocation and deallocation just increase and decrease the stack pointer. The issue with this approach is that extra code is needed to handle the funarg problem.
%
%Another approach is to allocate the stack frame on the heap, and let it be cleaned up with the garbage collector. The quality of this approach depends a lot on the garbage collector. In particular it has nearly no overhead with a good generational garbage collector \cite{generational-heap}.
%This also solves the funarg problem as the closure has a reference to the activation record, which will then not be garbage collected.
%
%Usually the variable is resolved at compilation time, or the first time it is encountered, but 
%some interpreters have a less efficient approach, where they look up variables at run-time, either through a stack, or a table of variables.
%
\chapter{Yolan}
\label{yolan}
\index{Yolan}
Yolan is an experiment in minimalism of language design and implementation. 
The goal is to minimise the code footprint, while still having a practical scripting language with first-class functions.
I call the language Yolan as a contraction of yocto-language, where yocto- is the SI-unit of $10^{-24}$ and thus means very very small.
Yolan also serves as a pilot system and stepping stone for further development.

We first describe the design choices that lie as a base for the language, then Section~3.2 elaborates on a detail in the implementation. Section~3.3 describes the language, and finally Section~3.4 describes how to embed the language within an application.

\section{Design choices}
The next paragraphs elaborate on the following design choices:
\begin{itemize}
\item The implementation must be able to run on CLDC 1.0
\item It should use standard Java classes, for easier interaction with Java code
\item Code should be loadable/executable as source code at run-time
\item Functions should be first-class values, to make the language more expressive
\item Variable look up should should be fast
\item Only integers will be supported, - no floating point numbers
\item Null is the false value
\item Syntax should be Lisp-like, to reduce the size of the parser
\item Scoping should be dynamic
\item Arrays, hashtables, etc. should be built in in the language
\item The interface with Java should be lazy, to allow implementation of custom control structures
\item Execution is online / one statement at a time
\item The implementation is single threaded/non-reentrant to reduce code size
\end{itemize}

CLDC 1.0 is the most limited device configuration and API for mobile devices. If the language is able to run this configuration, it will also be able to run on the other Java configurations, and then be able to run on most devices.

\label{yolandesign}
Use of standard Java classes instead of custom classes for builtin data types such as arrays or tables has three benefits: the code footprint is smaller, as these data types do not have to be reimplemented, it may be faster, as the builtins may be implemented natively, and it is more easily embeddable, as the developers already know the data types from standard Java and the host program may be using those data structures already.
Nevertheless, using the builtins gives less flexibility to the design of the behaviour of the data types in Yolan.

Being able to load code at run-time is important for several reasons:
It allows larger programs than would otherwise be possible within the devices, as the different parts of the program can be loaded and unloaded as needed.
It allows adding updates and new features to the programs, without needing them to be reinstalled manually.
It allows the language to be used for configuration files, and data initialisation.
Being loaded as source code both gives more clarity, and make the scripts easier to edit and deploy, thereby making it more suitable for use as configuration language, and scripting by users.

Functions should be first-class values, both to enable functional programming and increase the expressiveness of the language.


Variable access happens very often, so if the scripting language does a full lookup of the variable name at each access, it will be a bottleneck for the performance.
Instead the implementation must ensure that they are only resolved once for each place they are used in the source text.
%The platform is already slow, so performancewise we probably can not afford not doing this optimisation.

Integer is the only number type supported on the platform. Floating point numbers would have to be emulated on CLDC-1.0 based devices, which would both give a performance penalty, and more importantly a huge increase in code footprint due to emulation code.

Null is also the false value. This simplifies the implementation slightly, thereby reducing the footprint.

Yolan has a Lisp-inspired syntax. This makes the implementation of the parser trivial, and thus reduces code footprint.

Dynamic scope removes the issue of the funarg problem, and thus simplifies the implementation of variables, thereby reducing the implementation footprint. So this is chosen, although dynamic scope is generally bad language design.
\index{Scope}

The language is more like a traditional scripting language, than a functional language, 
as it does not support tail recursion nor does it use linked list as the basic language structure, but instead it uses resizable arrays and hashtable as data structures, and has a more imperative programming model, with while- and foreach-loops, etc.
The motivation for this is that it is simpler to implement efficiently on top of an already imperative/object-oriented virtual machine, and that functional languages often use more runtime memory.

Making the interface with Java lazy, allows new control-flow constructs to be added easily from Java by the embedder, which again allows the implementation to be a small core, with support for expansion.

Execution should be online, in the sense that whenever a full statement is read from the input, it should be executed, without needing to read the full file. This is both practical for interactive evaluation, and also has a benefit memorywise as the entire program never needs to be fully in memory, as executed code may be garbage collected.

By only having a single runtime, some classes can be made static and merged, leading to a smaller code footprint. This is a tradeoff leading to non-reentrant code and no support for threads.

\section{Syntax tree rewriting}

To make the interpreter as simple as possible, it interprets the syntax tree directly. Still this has some performance issues, as for example variable and function lookup must be done at each execution. To avoid the cost of this, some of the evaluation functions instead resolve the variables the first time they are executed and replace the node in the abstract syntax tree with a node of the resolved variable or function.

\section{Language specification}

\subsection{Syntax}
\subsubsection{Function applications / lists}
Function applications are written in Lisp-style as lists. The first element in the list is the function to be applied.
Lists are enclosed within square brackets \verb|[|$\cdots$\verb|]|, and may be nested. 
The reason to use square brackets, rather than parenthesis as in Lisp, is that the lists are not cons-lists, but instead arrays, which are usually written with square bracket notation in other scripting languages. This is also an indication that Yolan is not a proper Lisp-like functional language, but rather a scripting language. The notation is also similar to that of Tcl, except that there are not automatic expression breaks at newlines.
The elements within the lists are separated by whitespace. 
As lists are the notation for function applications, every list must have at least one element, which is an expression evaluating to the function to be applied.

\subsubsection{Variable names}
A variable name is a sequence of characters. The possible characters are letters, numbers, the symbols \verb"!#$'()*+-,-./:<=>?@\^_`{|}~", and any unicode symbol with a unicode value of 127 or higher. The first character in the name of a variable must be non-numeric.

\subsubsection{Integer literals}

Integers are written as a sequence of digits (\verb|0123456789|). Only base 10 input is possible and only non-negative numbers can be written as literals. Negative integers must be generated by subtraction.

\subsubsection{Comments and whitespaces}
Characters with a unicode value of 32 or less are regarded as whitespaces. These include the usual space, tab, newline, and line-feed. Whitespace is used to separate list elements, and is discarded during parsing. A comment must be preceded by whitespace, it starts with a semicolon \verb|;| and it continues until the end of the line. Comments are discarded during parsing.

\subsection{Builtin functions}
The builtin functions are listed below. As the language is designed for embedding in other applications, there are no standard functions for input/output, file access, network, etc. as these might not be present or differ significantly between target devices/platforms. 
This functionality can instead be added via Java functions added to the Yolan runtime.

%TODO: $ $ -> {\textit }
In the following, function names are written with {\tt fixed width} font, and their arguments are written in {\textit cursive}. An argument is named according to its type or functionality: $num$s are expressions that should evaluate to numbers, $exp$s are expressions that may be optionally evaluated (e.g. in {\tt if}), $val$s are expressions that will be evaluated, $string$s are expressions that should evaluate to a string, {\textit name} is the name of a variable, and so on.

\subsubsection{Variables}
\subsubsection*{\tt{[set }$name$ $value$\tt{]}}
Evaluate the expression $value$ and let the variable $name$ refer to the result.

\subsubsection*{\tt{[locals [}$name_1 \cdots name_n$\tt{]} $expr_1 \cdots expr_n$\tt{]}}
Let $name_1 \cdots name_n$ be local variables in $expr_1 \cdots expr_n$: First save the values corresponding to $name_1 \cdots name_n$, then evaluate the expressions $expr_1 \cdots expr_n$, next restore the values of $name_1 \cdots name_n$ and finally return the result of the evaluation of $expr_n$. The expressions are evaluated in order, with $expr_1$ as the first one, and $expr_n$ as the last one.

\subsubsection{Conditionals and logic}
\subsubsection*{\tt{[if }$cond$ $expr_1$ $expr_2$\tt{]}}
Evaluate $cond$ and if the result is non-$null$ then evaluate and return $expr_1$, else evaluate and return $expr_2$.

\subsubsection*{\tt{[not }$cond$\tt{]}}
If the value of $cond$ is $null$ return $true$ else return \textit{null}.

\subsubsection*{\tt{[and }$expr_1$ $expr_2$\tt{]}}
Evaluate $expr_1$ and if it is non-\textit{null}, evaluate and return the value of $expr_2$, else return \textit{null}.

\subsubsection*{\tt{[or }$expr_1$ $expr_2$\tt{]}}
Evaluate $expr_1$ and if it is non-\textit{null} return its value, else evaluate and return the value of $expr_2$.

\subsubsection{Repetition and sequencing}
\subsubsection*{\tt{[repeat }$num$ $expr_1 \cdots expr_n$\tt{]}}
Evaluate $expr_1 \cdots expr_n$ $num$ number of times ($num$ is evaluated once, and must evaluate to a number). The result is the last execution of $expr_n$, or \textit{null} if no expressions were evaluated, i.e. $num \leq 0$.

\subsubsection*{\tt{[foreach }$name$ $iterator$ $expr_1 \cdots expr_n$\tt{]}}
For every value from the $iterator$, bind it to the local $name$ and evaluate $expr_1 \cdots expr_n$. The result of the evaluation is the last executed $expr_n$ or \textit{null} if no expressions were evaluated. $name$ is a local variable, and is thus saved before the loop, and restored afterwards.

\subsubsection*{\tt{[while }$cond$ $expr_1 \cdots expr_n$\tt{]}}
While $cond$ evaluates to non-\textit{null}, evaluate $expr_1 \cdots expr_n$, and return the value of the last $expr_n$ or \textit{null} if no expressions were evaluated.


\subsubsection*{\tt{[do }$expr_1 \cdots expr_n$\tt{]}}
Evaluate $expr_1 \cdots expr_n$ and return the result of $expr_n$.


\subsubsection{Functions}
\subsubsection*{\tt{[lambda [}$name_1 \cdots name_n$\tt{]} $expr_1 \cdots expr_n$\tt{]}}
Create a new anonymous function, with the parameters $name_1\cdots name_n$. Application of the function will bind its arguments to local variables $name_1\cdots name_n$, evaluate $expr_1\cdots expr_n$ and return $expr_n$, saving and restoring $name_1\cdots name_n$ when entering and exiting the function.

\subsubsection*{\tt{[defun [}$name_{function}$ $name_1 \cdots name_n$\tt{]} $expr_1 \cdots expr_n$\tt{]}}
Create a new function, and bind it to the variable $name_{function}$. The \verb|defun| statement above is equivalent to {\tt{[set }}$name_{function}${\tt{ [lambda [}}$name_1 \cdots name_n${\tt{]}} $expr_1 \cdots expr_n${\tt{]]}}.

\subsubsection*{{\tt{[apply }}\textnormal{\textit{function}} $param_1 \cdots param_n$\tt{]}}
Apply the \textit{function} to the parameters $param_1\cdots param_n$. The difference between this and the usual function application {{\tt{[}}\textit{function} $param_1\cdots param_n$\tt{]}} is that that \verb|apply| allows \textit{function} to change between invocations, whereas the usual function application assumes that \textit{function} is static, to be able to optimise it during runtime.

\subsubsection{Integer operations}
\subsubsection*{\tt{[+ }$num_1$ $num_2$\tt{]}}
Calculate the sum of two integers.
\subsubsection*{\tt{[- }$num_1$ $num_2$\tt{]}}
Calculate the difference of two integers, the result is $num_2$ subtracted from $num_1$.
\subsubsection*{\tt{[* }$num_1$ $num_2$\tt{]}}
Calculate the product of two integers.
\subsubsection*{\tt{[/ }$num_1$ $num_2$\tt{]}}
Calculate $num_1$ divided by $num_2$.
\subsubsection*{\tt{[\% }$num_1$ $num_2$\tt{]}}
Calculate the remainder of dividing $num_1$ by $num_2$.

\subsubsection{Type predicates}
\subsubsection*{\tt{[is-integer }$val$\tt{]}}
Returns $true$ if $val$ is an integer.
\subsubsection*{\tt{[is-string }$val$\tt{]}}
Returns $true$ if $val$ is a string.
\subsubsection*{\tt{[is-list }$val$\tt{]}}
Returns $true$ if $val$ is a list.
\subsubsection*{\tt{[is-dictionary }$val$\tt{]}}
Returns $true$ if $val$ is a dictionary.
\subsubsection*{\tt{[is-iterator }$val$\tt{]}}
Returns $true$ if $val$ is a iterator.

\subsubsection{Polymorphic functions}
\subsubsection*{\tt{[equals }$val_1$ $val_2$\tt{]}}
Compare $val_1$ to $val_2$ and return $true$ if they are the same, or \textit{null} if they are different. $val_1$ and $val_2$ must have the same type.
\subsubsection*{\tt{[is-empty }$val$\tt{]}}
Returns $true$ if a list, dictionary or iterator does not have any elements. Otherwise, it returns \textit{null}.
\subsubsection*{\tt{[put }$container$ $position$ $value$\tt{]}}
Store a value into a list or a dictionary. If the container is a list, the $position$ must be an integer in the range $0,1, \cdots, ${\tt{[size }}$container${\tt{]}}$-1$.
If the container is a dictionary, the position must be a string or an integer. An entry is deleted from a dictionary by storing \textit{null} as the $value$.
\subsubsection*{\tt{[get }$container$ $position$\tt{]}}
Retrieve a value from a list or a dictionary. The same on $position$ are the same as with \verb|put|. Retrieving an uninitialised entry from a dictionary yields \textit{null}.
\subsubsection*{\tt{[random }$val$\tt{]}}
If $val$ is an integer, return a random number in the range $0,1, \cdots, val -1$. If $val$ is a list, pick a random value from the list.
\subsubsection*{\tt{[size }$val$\tt{]}}
Return the length of a string, the number of values in a list, or the number of entries in a dictionary.
\subsubsection*{\tt{[< }$val_1$ $val_2$\tt{]}}
Compare $val_1$ with $val_2$. If $val_1$ and $val_2$ are integers, return $true$ if $val_1$ is strictly less than $val_2$ and otherwise \textit{null}.
If $val_1$ and $val_2$ are strings, do a lexicographic comparison and return $true$ if $val_1$ comes strictly before $val_2$, and otherwise \textit{null}.
\subsubsection*{\tt{[<= }$val_1$ $val_2$\tt{]}}
Compare $val_1$ with $val_2$. If $val_1$ and $val_2$ are integers, return $true$ if $val_1$ is less than or equal to $val_2$ and otherwise \textit{null}.
If $val_1$ and $val_2$ are strings, do a lexicographic comparison and return $true$ if they are equal or $val_1$ comes before $val_2$, and otherwise \textit{null}.

\subsubsection{String functions}
\subsubsection*{\tt{[stringjoin }$val_1\cdots val_n$\tt{]}}
Create a string by concatenating $val_1\cdots val_n$.
If $val_i$ is an integer or a list, it is converted to a string.
A list is converted to a string by concatenating its elements, as if {\tt stringjoin} were called with the list elements as arguments.

\subsubsection*{\tt{[substring }$string$ $num_{begin}$ $num_{end}$\tt{]}}
Create a substring from a string, starting inclusively at character position $num_{begin}$ and ending exclusively at character position $num_{end}$. The positions starts counting at $0$, so thus {\tt{[substring }$string$ $0$ \tt{[size }$string$\tt{]]}} is the entire string.

\subsubsection{List functions}
The following functions work on lists. Notice that lists in Yolan are similar to lists in Python, and thus the functions below are imperative in that they alters the list parameter, which is different to what happens in functional languages, where lists are typically cons-cells. The end of a list is the element at the position equal to the length of the list minus one.

\subsubsection*{\tt{[list }$val_1\cdots val_n$\tt{]}}
Create a new list, containing the elements $val_1\cdots val_n$.

\subsubsection*{\tt{[resize }$list$ $num$\tt{]}}
Change the size of the $list$ to be $num$ elements. 
If the new size is larger than the current size, new elements will be added to the end of the list, with the initial value of \textit{null}. If the new size is smaller than the current size, then the list will be truncated at the end. The list is modified by the function and then returned.

\subsubsection*{\tt{[push }$list$ $val$\tt{]}}
Push the value $val$ at the end of the $list$. The size of the list grows by one, and the last element is now $val$.

\subsubsection*{\tt{[pop }$list$\tt{]}}
Remove the element at the end list. The function returns that element, and reduces the size of the list by one.

\subsubsection{Dictionary functions}
\subsubsection*{\tt{[dict }$key_1$  $val_1$ $\cdots$ $key_n$ $val_n$\tt{]}}
Create a new dictionary with $n$ entries, where $key_1$ maps to $val_1$ and so forth.

\subsubsection{Iterator functions}
\subsubsection*{\tt{[keys }$dictionary$\tt{]}}
Create a new iterator across the keys of a dictionary.
\subsubsection*{\tt{[values }$container$\tt{]}}
Create a new iterator across the values of either a dictionary or a list.
\subsubsection*{\tt{[get-next }$iterator$\tt{]}}
Get the next element from the iterator, or \emph{null} if the iterator is empty.

\section{Developer guide to embedding Yolan in Java}
%Yolan is a minimal scripting language implemented on Java.
%It allows scripting to be added to an application, with a minimal overhead in the size of the JAR file -- which is the most limiting factor on low-end mobile devices. The features and limitations of Yolan are:
%\begin{itemize}
%\item It is scripting language, with support for higher-order functions
%\item Yolan supports loading of code at run-time
%\item The datatypes of Yolan is implemented with the classes from the Java standard library, such as \verb|java.lang.Integer|, \verb|java.util.Hashtable| and \verb|java.util.Stack|, which makes it easier to interact with Java applications.
%\item It is implemented on top of Java Micro Edition/J2ME, and requires only CLDC 1.0.
%\item Adding scripting support to an application adds approximately 5KB to the size of the optimised JAR file
%\item Expressions are parsed and executed one at a time, allowing interactive programming, and implying that the entire program need not to be in memory at once
%\item Yolan scripts are interpreted -- they can be entered directly on the device, not needing an extra step of compilation, and thus it is also suitable for scriptable configuration files, user scripts etc.
%\end{itemize}

The implementation of Yolan consists of a single class, \verb|Yolan|, containing the actual implementation, and an interface \verb|Function|, which specifies what a class needs to implement in order to be callable from Yolan.
While Yolan only has a single classfile for the implementation, in order to reduce the JAR file size, it consists of several logical classes: a parser implemented as static properties,\footnote{A static property is a property pertaining to the class rather than to the object} a runtime implemented as static properties, and delayed computations are the actual instantiated objects.

Having a single runtime reduces memory usage, but also limits applications to only executing a single script, and only having a single execution context at a time. The reduction of memory usage comes from the fact that refererences to the execution context can be hard coded, and thus the delayed computations do not have to carry a reference to the context. There is also a memory reduction because less code is needed and the class for the context can be joined into the main class file, as static properties.
The delayed computation is the same as a node in the abstract syntax tree, as the scope is dynamic and execution context is global. 


The \verb|Function| interface consists of a function that takes an array of Yolan objects -- delayed computations -- as a parameter, and then returns a value. In this sense Java objects callable from Yolan are essentially lazy functions, and responsible themselves for evaluating their arguments. This makes it easy to add custom control function, similar to \verb|if| and \verb|while|, as it is left up to the called Java function whether, and how many times, each argument expression should be evaluated.

\subsection{Getting Started}
The core method of a Yolan object is the \verb|value()| method which evaluates the code the Yolan object represents, and returns the result. This method may throw \verb|Exeception|s as well as \verb|Error|s if the code it represents has faults, so to make it robust against errors in scripts, the Yolan evaluation must be surrounded by a \verb|catch(Throwable)|.

Yolan objects are created with the static \verb|readExpression| method that parses the next Yolan expression from an input stream. So if we want to create a simple interactive interpreter, reading from the standard input stream \verb|System.in|, we can implement it in Java as: \begin{lstlisting}
class Main {
    public static void main(String [] args) throws java.io.IOException {
        Yolan yl = Yolan.readExpression(System.in);
        while(yl != null) {
            try {
                System.out.println("Result: " + yl.value().toString());
            } catch(Throwable yolanError) {
                System.out.println("Error: " + yolanError.toString());
            }
            yl = Yolan.readExpression(System.in);
        }
    }
}\end{lstlisting} 

This code could be saved in a file called Main.java, placed in a directory with Yolan.class and Function.class, and then compiled and executed by executing \verb|javac Main.java| and \verb|java Main|.

Notice that the input stream \verb|System.in| can be replaced with any input stream, so the same idea can be used for evaluating files, programs as strings within the application, or even as streams across the network, where Yolan could work as a shell for remote scripting/controlling an application.

If we want to execute an entire stream, there is a shorthand builtin method for doing that: \verb|eval|. For example:
\begin{lstlisting}
class Main {
    public static void main(String [] args) throws java.io.IOException {
        Yolan.eval(new FileInputStream(new File("script.yl")));
    }
}
\end{lstlisting}
This code opens the file ``script.yl'', and evaluates all the expressions within it. 
\verb|eval| throws away the results of the individual expressions and does not print them,
so the above code is only useful if we have added some user defined functions to Yolan that allow some kind of input or output.

\subsection{Adding functions to the runtime}
Yolan needs to call Java functions to do anything practical, and this section shows how to make Java code available for Yolan.
While the builtin Yolan functions support basic data structures such as lists and dictionaries,  there is no built in way to do input/output from Yolan, as that is platform dependent: Java Standard Edition supports files, while Java Micro Edition has a record store, and user interfaces ranges between Midlets, Applets, graphical applications, and text standard-in/out.
\index{Java Micro Edition}
So when a script needs to communicate with the user, or work on the state of the host application, 
some functionality needs to be added. This is most easily done by adding functions to the runtime.

The \verb|Function| interface is the way to do that. To implement the interface a single function, \verb|apply|, needs to be implemented in the class. 
This function performs the actual application of the function within Yolan, and
it takes an array of delayed computations (instances of the \verb|Yolan|-class) as argument, and returns the result as a usual object.
The delayed computations they are only evaluated when the called function chooses to evaluate them, by calling their \verb|value()|-function.
Execution of the delayed computations may also have side effects, and thus the number of times \verb|value()| is called per argument matters.

In order to add a new Java function to be callable from the runtime, the method \verb|Yolan.addFunction| takes a string name and a \verb|Function| as parameters, and binds the name to the function. As an example the following code makes a new function, \verb|println|, available to the runtime. This function takes one argument, which it prints to the standard output:
\begin{lstlisting}
class PrintingFunction implements Function {
    Object apply(Yolan args[]) {
        System.out.println(args[0].value());
    }
}
class Main {
    public static void main(String [] args) throws java.io.IOException {
        Yolan.addFunction("println", new PrintingFunction);
        Yolan.eval(new FileInputStream(new File("script.yl")));
    }
}
\end{lstlisting} 
The above program reads and evaluates the file script.yl, with an augmented runtime that also has the \verb|println| function.

\subsection{Code-footprint-efficient addition of multiple functions to the runtime}
The naive approach for adding functions to the runtime would be to create a new class implementing the \verb|Function| interface for each function. This would add significantly to the size of the JAR-file.
If the code size is critical, it can often be reduced by combining multiple functions into a single class, for example via a switch dispatch as shown below:
\begin{lstlisting}
class ManyFunctions implements Function {
    int id;
    ManyFunctions(int id) {
        this.id = id;
    }
    public Object apply(Yolan args[]) {
        switch(id) {
            case 0: // first function
                    ....
                break;
            case 1: // second function
                    ....
                break;
            case 2: // third function
                    ....
                break;
            ....
            default:
                throw SomeKindOfError();
    }
    static void register() {
        Yolan.addFunction(new ManyFunction(0), "firstFunction");
        Yolan.addFunction(new ManyFunction(1), "secondFunction");
        Yolan.addFunction(new ManyFunction(2), "thirdFunction");
        ....
    }
}
\end{lstlisting}

When implementing functions, it is also possible to create control structures, due to the laziness of Yolan objects. This is done by not evaluating the arguments' \verb|value|-functions exactly one time each, but zero or more times, depending on the purpose. The example below shows how the usual if-statement could be implemented:
\begin{lstlisting}
class YolanIf implements Function {
    public Object apply(Yolan args[]) {
        // first evaluate the condition
        // and find out if it i true (not null)
        if(arg[0].value() != null) {
            // only evaluate if the condition yields true
            return arg[1].value();
        } else {
            // only evaluate if the condition yield false
            return arg[2].value();
        }
    }
}
\end{lstlisting}
\subsection{Values and types}
The builtin types in Yolan are mapped to Java classes for easier interoperability,
so lists are implemented as java.util.Stack, dictionaries are implemented as java.util.Hashtable, strings are implemented as java.lang.String, null/false is implemented as the value null, integers are implemented as java.lang.Integer, and iterators are implemented as java.util.Enumeration. 
Operations on those data types are just as in Java.

Any Java object can be passed around within Yolan, so adding support for new data types is just a question of adding functions that work on values of those data types.

\subsection{Functions defined within Yolan}
When a user defines functions within Yolan, they are instances of the Yolan class. 
Before calling such a function, the number of arguments can be found using the \verb|nargs| method.
If the Yolan object is not a callable user-defined function, the result of \verb|nargs()| is -1, and this is the only API method needed to check if a Yolan object is a callable function.
This function is then applied with the \verb|apply| method, which takes the arguments to the function as arguments, for example:
\begin{lstlisting}
...
    // evaluate some Yolan object that yields a function
    Yolan function = yl.value();
    // ensure that it is a function and it takes two arguments
    if(function.nargs() == 2) {
        // apply the function 
        result = function.apply(arg1, arg2);
    } else ...
....
\end{lstlisting}
The apply method is defined from zero up to three arguments. If there is a need for an apply method with more arguments, they are simple to add; see page~\pageref{source-yolan-apply} for the implementation details. There is also a general apply method, that takes an array of arguments as argument.

\subsection{Modifying the runtime}

In order for the scripting language to be practical, it should be able to work with and share data with the host application. 
Of course this can be done with functions, and evaluation, as described above, but an additional connection with the language can be added by accessing the variables defined, and used, by the running scripts.
For this there are three functions: \verb|Yolan.resolveVar|, \verb|Yolan.getVar|, and \verb|Yolan.setVar|.

When the value of a variable is accessed, this is done through a handle, which is found using \verb|resolveVar|. This handle can then be used for reading and writing the variable. The motivation for the handle is that it takes time to look up a variable name, so this computation can be done once for each variable that needs to be accessed, and then additional accesses to the resolved variable are significantly faster. The \verb|resolveVar| function takes the variable name as a string parameter, and returns the handle, which is an integer. If the variable does not exist in the runtime, space is allocated for it.

With a handle, it is then possible to set the value of a variable with \verb|setVar|. For example setting the variable foo to 42 can be done with:
\begin{lstlisting}
    Yolan.setVar(Yolan.resolveVar("foo"), new Integer(42));
\end{lstlisting} 
and similarly the variable can be read with \verb|getVar|:
\begin{lstlisting}
    Object result = Yolan.getVar(Yolan.resolveVar("foo"));
\end{lstlisting}

If it the variable is commonly accessed, it saves time to cache the handle across calls, as follows:
\begin{lstlisting}
class Class {
    int fooHandle;
    Class() {
        fooHandle = Yolan.resolveVar("foo");
    }

    int someMethod() {
        ... perhaps some scripts modifying foo are executed ...
        Object foo = Yolan.getVar(fooHandle);
        ...
    }

    void otherMethod() {
        ... 
        Yolan.setVar(fooHandle, "A literal value or some variable");
        ...
    }
}
\end{lstlisting}
When defining functions, as described earlier, it is actually the same that is happening: the function is encapsulated in a Yolan object and added to the runtime as done by \verb|setVar|.

\subsection{Resetting the runtime and saving space}
When the scripting language is only used in some parts of the application, it can be pratical to be able to unload its runtime data in order to save memory. 
For this there are two utility functions \verb|Yolan.wipe()| and \verb|Yolan.reset()|.

\verb|Yolan.wipe()| sets all references in the runtime to zero, allowing data to be garbage collected.
When the runtime has been wiped, Yolan expressions can no longer be evaluated, and trying to evaluate them yields errors. 

\verb|Yolan.reset()| resets the runtime: all variable handles are invalidated, all variables are removed from the runtime, and only the builtin functions remain. Existing Yolan expressions are invalid, and evaluation of them may lead to unexpected behavior. User defined functions and variables need to be re-added.
Resetting is necessesary before scripts are executed after a \verb|Yolan.wipe()|.
It can also be practical when multiple scripts are run, one after another, and they must not modify the runtime for each other.

\chapter{LightScript}
\label{lightscript}

The purpose of LightScript is to make a practical scripting language for mobile devices. 
It should overcome some of the limitations of Yolan. In particular LightScript should support lexical scope to allow real closures, and it should not invent a new syntax, but build on a mainstream language in order to be readable and easy to learn for other programmers.

As for the name of the language, I chose to call it LightScript, as it is a lightweight scripting language, and a light (reduced) version of JavaScript. The name also has an aspect of illumination, and the ``-Script'' suffix also indicates the connection with JavaScript/EcmaScript whose dialects often have names with this suffix.

LightScript is a moving target, as I continually improve the code. Most of this chapter discusses LightScript version 1.0 as that was the language as it looked at the beginning of writing the report.

Section~4.1 gives an introduction to the design choices of the language. The next three sections, Section~4.2-4.4, look into some implementation details. Then, Section~4.5 describes the language, and Section~4.6 is a guide to how to embed, use, and integrate it with mobile Java applications.
Section~4.7 looks into future directions, and outlines the current status of LightScript version 1.1. 

\index{LightScript}
\section{Design choices}
\label{lightscript-design}
This section first lists the design choices of LightScript version 1.0, which are then elaborated on in the following paragraphs.
The main design choices that distinguish LightScript from Yolan are:
\begin{itemize}
\item LightScript should be a subset of EcmaScript
\item Scoping is lexical, and the language has closures
\item Objects are supported, and have prototypical inheritance with a self-like \verb|clone| function
\item Exceptions are supported, and can be thrown to, from and across Java code
\end{itemize}
In addition to these, there are also some language design choices that are similar to those of Yolan:
\begin{itemize}
\item It must be able to run on CLDC 1.0
\item Standard Java classes should be used for the builtin types, to make interaction with Java code easier
\item Code should be loadable/executable as source code at run-time
\item Functions are first-class values
\item Parsing does not need to be concerned about error checking
\item Only integers will be supported, - no floating point numbers
\item Undefined, null and false, are joined into a single type/value. This joined value is the only false value
\item Variable access should be fast
\end{itemize}

There are several reasons to make the language a subset of EcmaScript:
This allows it to automatically run within most web browsers, including within smartphones where Java may not be installed.
\index{Smartphones}
Being an EcmaScript subset also makes it easier for developers, that already know EcmaScript, or other languages with C-like syntax, to get started with.
Nevertheless, being a subset of EcmaScript will also add more complexity to LightScript, and EcmaScript has some unfortunate design choices \cite{crockford-web}, for example: 
Variables are global by default.
Scope is limited by functions rather than blocks, which is unusual.
The usual equality operator \verb|==| does type coercion leading to non-transitivity, so \verb|===| should be used instead.
Traversal of objects through for-each loops also traverse the prototype of the object which is usually not the intended semantic.
Arrays and \verb|null| are objects in typeof-operator, leading to more complex type test for those values as well as objects.
The many reserved word adds unnecessary restrictions to naming of properties and variables.
Automatic semicolon insertion encourages sloppy programming style.
For compatibility with EcmaScript, some of these will be a part LightScript,
although many can be omitted by being a subset and thus more strict. 

LightScript should have a lexical scope similar to EcmaScript.
This has the benefit of allowing closures which makes the use of functions much more expressive.
The lexical scope in EcmaScript, and thus LightScript, is a bit different from most other lexical scoping, as the scope limit is the enclosing function rather than the block.
\index{Scope}
\index{Closure}

LightScript should support an object system similar to EcmaScript.
Inheritance will be slightly different: while EcmaScript has prototypical inheritance, it mixes it with some Java/C++like syntax. The semantics will be the same for LightScript, but the inheritance will be done with a self-like \verb|clone| clone, which seems more pure prototypical than EcmaScripts syntax. The \verb|clone| function can easily be implemented in EcmaScript.

Exceptions should also be supported, and it should also be possible to throw between, and across Java-functions and LightScript functions.


Like Yolan, LightScript will run on CLDC 1.0, and will use standard classes for easier embedding and lower code footprint size. It will support run-time loading of source code, and will have functions as first-class values. See the Yolan design choices on page~\pageref{yolandesign}.

The parser may assume that the programs have valid syntax. 
Usually parsers both build a syntax tree of valid programs and also reject programs with invalid syntax. 
By removing the rejecting part, and only requiring that the parsers can build a syntax tree from valid programs, the parser may be optimised to run better on limited devices.
The parser should still be guarenteed to terminate, even with invalid programs though the resulting syntax tree may be undefined.

LightScript only supports integers as number type, due to the platform. This is radically different from EcmaScript, which only supports floating point numbers. Scripts can still be compatible: addition, and multiplication, subtraction and modulo operations stay within the integer subset of floating point numbers, as long as there is no overflow and they start out with integers. The shifts and bitwise operators temporarily cast to integers in EcmaScript, so they are not an issue. The only problem of the operators is division, and the solution here is to omit the \verb|/| binary operator from LightScript, and instead allow integer division to be implemented as a function \verb|div|, which can also be implemented in EcmaScript with a combination of division and rounding.

Similar to Yolan, LightScript also only has one false value, which also joins the \verb|undefined|, \verb|null|, and \verb|false| value of EcmaScript, which also removes the boolean type. This is an optimisation that makes truth test faster and slightly smaller, as they can be written as \verb|obj != null|, rather than
{\tt !( obj == null \verb%||% (obj instanceof Boolean \verb%&&% !((Boolean)obj).booleanValue()) \verb%||% (obj instanceof Integer \verb%&&% ((Integer)obj).intvalue() == 0) \verb%||% (obj instanceof String \verb|&&| obj.equals(""))}. It is still possible to preserve compatibility of scripts with EcmaScripts by requiring that conditions are always boolean values -- as it is required in many static typed languages. Another issue with this choice is, that there is no distinction between \verb|undefined| and \verb|null|, which may be desirable.

Similarly to Yolan, LightScript should support fast variable access. This also means that another approach than looking through the chain of execution context objects, as described in the EcmaScript standard, must be used. Here LightScript should use a usual execution stack, boxing objects in the closure onto the heap.

\section{Imperative implementation of top-down operator precedence parsers}
\index{Top-down operator precedence parser}
\label{tdop-imp}
This section looks at how top-down operator precedence parsers can be implemented efficiently in an imperative language.

As we have relaxed parsing requirements, such that only building the syntax tree, and not checking for error is required, several classes of tokens can be joined. An example is to create an end-of-list token, instead of list termination such as \verb|}|, \verb|)|, \verb|]|, which also allows a generalisation of parsing a list. Similarly a separator token can be introduced instead of ``\verb|,|'', ``\verb|;|'', and ``\verb|:|''.

The top-down operator precedence parser described in Section~\ref{tdop} 
uses first-class functions and is thus better suited for being implemented in functional languages rather than imperative languages.
For example, in Java a simple implementation of the parser uses a lot of space as the functions would use a class each, in order to be passed around as first-class values.
Our solution is to use a dispatch function instead, and replace the denominator functions of the token, with integers.
Actually it is simpler with two dispatch functions, one for the null denominator functions and one for the left denominator functions.

The token object contains information about the denominator functions, and corresponding abstract syntax tree node IDs, and also a priority/binding power.
This is just five small integers, which, due to their limited range, easily can be represented within a single 32bit integer. 
Some tokens represents literal values or identifiers, where the value or identifier also has to be passed to the parser.
So a token can be represented compactly as an integer and possibly an object for the value, which eliminates the need for an actual token object in the parse, thereby reducing the footprint by not needing a token class.

The token types can be encoded by the string representing the token followed by the five integers.
The token name string is not needed by the parser, but is used by the tokeniser, to map the token to the IDs.
So the tokens can be written as {\tt "tokenname" + (char) binding\_power + 
(char) null\_deno}\-{\tt{}minator\_function + (char) AST\_ID\_for\_null\_denominator
+ (char) left\_denomina}\-{\tt{}tor}\-{\tt{}\_function + (char) AST\_ID\_for\_left}\-{\tt{}\_denominator}. 
The syntax is implemented as a list of the different token types, with the data described above.
For this to be executed there also need to be a parse loop, and definitions of sensible denominator function bodies within the dispatch.
The actual implementation can be seen on page~\pageref{code-lightscript-parser}.


\subsection{Performance properties of the parser implementation}

For each token, there is an instruction cost of 1-2 function calls, 1 switch-dispatch, 0-1 comparisons, extracting 2-3 parts of the token integer, and storing a copy of the token integer, plus the cost of building the actual AST node, and the cost of the tokenisation itself.

The size of the implementation can be kept very small, as the denominator functions can be reused across different token-types. For example: the binary operators share a single case in the left denominator dispatch, and adding a new binary operator only uses the length in characters of the operator plus 5 bytes. 

\section{Implementation of variables and scope}
\index{Scope}
In the EcmaScript standard, identifier resolution is done by searching through the scope chain, which is a list of objects. An object in the EcmaScript context is a mapping from property names to values. This approach to implementation would be very performance expensive.

Instead we want to resolve the variables at compile time, while preserving as much of the EcmaScript semantics as is practical. The main issue here is that when we resolve the variable at compile time, we do not keep information to be able to resolve it dynamically at run-time,
which lead to limitations in \verb|eval| like statements when compared to the EcmaScript semantics. Currently there is no \verb|eval| statement in LightScript, but this may be an issue in future versions.

Of the different methods for implementing scope, discussed in Section~\ref{survey-scope}, the only real possibility for a partly imperative scripting language with support for first-class functions is either to allocate the activation records on the heap, or to keep track of variables that could live on after exiting a function, and box those variable on the heap.
The other options are ruled out, as we want to have closures, and we want the outer scope variables to be mutable.
\index{Closure}
As we are implementing on top of the JVM, we inherit its garbage collector, which may vary between different devices, and which may be badly suited for activation record allocation on the heap.
So the approach will be only to box variables onto the heap that could be alive after function exit.
To simplify this every variable that is added to a closure of an inner function is boxed on the heap, and other local variables are just stack allocated in the usual way. 
%TODO: reference nanopass compiler paper by Kent Dybvig (ICFP in Snowbird) or other papers by dybvig
%I have not seen this exact approach to implement closures other places, but it seems so obvious, that it is probably done somewhere before, although it clearly is different from the Lua approach with upvals \cite{luasrc}, and also from the approach following the EcmaScript standard \cite{ecmascript} directly.

For the practical implementation of the stack on top of the JVM, there are two obvious possibilities: A \verb|java.util.Stack| object could be used, or a stack could be implemented manually with an array and an index pointer. 
In order to select implementation strategy, a microbenchmark was done on the KVM, which indicated that the array approach is significantly faster than the \verb|java.util.Stack|. The array grows dynamically when entering a function that uses more stack space than is available. 
The code footprint size is similar for both approaches, though probably a bit smaller for the {\tt java.util.Stack}, as that one automatically grows, unlike the array approach, which needs a manual implementation.
The actual access to a \verb|Stack| requires a method call, which is 3 bytes plus 1-3 bytes for self and parameter loading, where reading from an array is a single byte opcode plus 2-4 bytes for self, index and parameter loading, and at the same time the array approach sometimes needs to adjust the index, costing 3 bytes.

\section{Overview of the implementation}
The core of the LightScript implementation consists of three parts: 1) a top-down operator precedence parser that is responsible for building the syntax tree, and for identifying which variables needs to be boxed on the heap for closures, 2) a compiler that translates the abstract syntax tree to a sequence of opcodes while keeping track of the stack depth, and 3) a stack-based virtual machine that executes the code.
Besides these core elements, the implementation also contains an API for embedding, and a library of standard functions.

The parser is a concrete implementation of the top-down operator precedence parser for imperative language, as described in Section~\ref{tdop-imp}, with the additional detail that during the parsing, the parser keeps track of which variables are defined and used in each function, such that this information can be used for scoping later on. 
The source code for the parser starts on page~\pageref{code-lightscript-parser}.
\index{Top-down operator precedence parser}

\subsection{Compiler}

The core of the compiler is a function that compiles a node of the syntax tree, possibly calling itself recursively for the children.
As it is compiling to a stack-based virtual machine, the compilation itself can be quite simple/small, as a function or operator just needs to evaluate its parameters in a way that pushes the results to the stack, followed by doing the operation on the top elements of the stack.

As the activation records are allocated on the execution stack. The compiler keeps track of the stack depth of the emitted code, such that there is no need for a frame pointer at execution, but variables is referenced relative to the stack top.

The abstract syntax tree does not distinguise between statements and expressions. Instead the compiler takes a parameter that indicates whether the generated code is expected to push a result on the stack or not, and corresponding code will be generated. 

By having the integer for the abstract syntax tree node type matching the virtual machine instruction, many of the compilation cases can be joined.


\subsection{Virtual Machine}
The virtual machine is stack-based in order to reduce the footprint of the compiler.
It is implemented with a single larger switch statement as it is running on top of JVM and the JVM does not support for references to labels, etc.
The instruction set is inspired by the JVM and calling conventions on i386, and it is also a product of the incremental development.
\index{Virtual machine}


\section{Language specification}
\index{Language specification!LightScript}
The language is mostly a subset of EcmaScript \cite{ecma-262}, and the description of the different parts of the languages is written in the same sequence as the EcmaScript standard, to make it easier to compare the two. The focus will be on where LightScript differs from EcmaScript.
Scripts written for LightScript also run unaltered in EcmaScript compliant interpreters, with a couple of extra functions defined within EcmaScript. On the other hand, EcmaScript may or may not run within LightScript, as LightScript is only a subset of EcmaScript.

The specification is stricter than the actual implementation, for example: the implementation does not distinguish between statements and expressions, and it allows a statement everywhere an expression could be written, whereas the specification follows EcmaScript, and distinguishes the two.

Only a relatively small subset of EcmaScript is implemented: operators have been added as needed, meaning that rare operators have not yet been added. 
On the other hand, more interesting language aspects, such as exceptions and prototypical inheritance, have been implemented and tested, though they may not have been needed for the example programs or benchmarks.

%The specification below follows the overall structure of the EcmaScript specification, in order to make it easier to compare the two.


\subsection{Lexical conventions}
The lexical conventions are slightly different from EcmaScript. 
Whitespaces are space, tab, carriage return and line feed. 
LightScript does not distinguish between whitespace and line terminators, and does not have automatic semicolon insertion.

Comments starts with two consecutive slashes \verb|//| and run to the next newline character.

Keywords reserved by EcmaScript are also reserved by LightScript. The keywords currently used by LightScript are: {\tt catch do else for function if return this throw try var while}. 

An identifier starts with a letter or an underscore and continues with any combination of letters, underscores and digits. 
LightScript does not support escaped unicode sequences, but does accept utf-8 encoded. Non-letter unicode symbols with value larger than 127 are not supported. This allows the parser to be implemented more easily as they can just treat any 8-bit character with a value larger than 127 as a part of a unicode letter.

The punctuators in the current version of LightScript are: {\tt \verb|{| \verb|}| ( ) [ ] . ; , < > <= >= === !== + - * \% >> ! \&\& || ? : = += -=}. 
Floating point division is omitted, but an integer \verb|div| operator can be added, as discussed in Section~\ref{division} on page~\pageref{division}.

String literals are always enclosed in double qoutation \verb|"|, and single quotation is not supported. It is possible to use backslash \verb|\| to escape quotation marks, backslashes and newline (\verb|"\n"| is the string containing a newline).

Integer literals are written as a sequence of digits, not starting with a zero, unless the number is zero. Only base 10 literals are supported.

Other literals are \verb|true| which translate to a value that has a true truth value, and \verb|false|, \verb|null| and \verb|undefined| which translates to a value that has a false truth value.

\subsection{Types}
LightScript has 5 builtin types: nil, string, number, array, and objects.

The nil type only has one value, which is referenced as \verb|undefined|, \verb|null| or \verb|false|. 
A string is an immutable sequences of characters.
A numbers is a 32 bit integer.
An array is a growable and mutable sequence of values, where the values can have any type.
An object is a mapping between names and values, where the name should be of string type, and the value can be of any type. An object can have another object as its prototype, such that if the lookup in the first object does not find a mapping, the name is then looked up in the prototype object.
The order of traversal of the object names/values, may be implementation dependent in that implementations may choose to implement them via hashtables or lists, depending on what makes most sense for the platform. This is different from EcmaScript, where the traversal is in the order the properties were added to the object.
\index{Prototypical inheritance}

\subsection{Execution contexts}

Variables defined with the \verb|var| keyword are allocated in the current function's activation record. 
A new activation record is created at each function call. 
If a variable is not in the current function's activation record,
it is looked up in the lexically enclosing function, or if there is no outer function, in the global scope.
This is the usual static scoping, where functions are the only way to make a scope closure.
\index{Scope}

%TODO: a bit about omitting bad parts of ecmascript, mentioned earlier in the design, more references to footprint
\subsection{Expressions}

When a function is called as a property on an object, evaluation of \verb|this| within the function yields the object.  Identifiers are evaluated in the scope to yield a value. Literal values are just their actual values.

Arrays are initialised with square brackets \verb|[| $elem_1,\cdots,elem_n$ \verb|]|. Elements can be any expression, and they are separated with commas (\verb|,|). 
Objects can similarly be initialised with curly brackets: \verb|{| 
$key_1: value_1, \cdots key_n: value_n$ \verb|}|, where the keys must be string literals, and values can be any expression.

Parenthesis can be used to group expressions together, for example: $2 * (3 + 4)$ is different from $2 * 3 + 4$

Objects and arrays can be subscripted with the bracket notation: $object$\verb|[|$key$\verb|]|, where $key$ can be any expression. The dot notation can be used as a shorthand for the case where $key$ is a string literal, such that $object$\verb|.|$name$ is equivalent to $object$\verb|["|$name$\verb|"]|.

The \verb|new| operator from JavaScript is not needed, and is therefor not supported in LightScript.
A new object can be written as an object literal, created by constructor function, or be \verb|clone|d for inheritance.

Function calls are written as an expression followed by, a possibly empty, parenthesised argument list, e.g. $func$\verb|(|$arg_1,\cdots,arg_n$\verb|)|, where the arguments are separated by commas. 
A LightScript function currently have a fixed number of arguments.

Postfix operators are not supported. Their implementation would add slightly more to the code space than the prefix versions.

The implemented prefix operators are \verb|++|, \verb|--|, \verb|-|, and \verb|!|, which work as usual. The \verb|typeof| operator is omitted due to its unfortunate semantics \cite{crockford-web}, and instead a \verb|gettype| function is supplied, which can easily also be implemented on top of EcmaScript.

The implemented binary arithmetic operations are: multiplication \verb|*|, modulo \verb|%|, addition \verb|+|, subtraction \verb|-| and right shift \verb|>>|. Except for addition, these work only on numbers. For addition, if one of the arguments is not a number, it does string concatenation instead.  Division \label{division} is not implemented as \verb|/|, due to the semantic differences in integer and floating point division, but can instead be implemented as an integer division function, \verb|div(|$a,b$\verb|)|. 

Comparison operators are \verb|<|, \verb|<=|, \verb|>|, \verb|>=|, \verb|!==|, \verb|===|, which works as usual. The equality operators do an actual comparison\footnote{This is equivalent with the Jave {\tt .equals}- method.} and not just a pointer comparison. 
The type coerced equality operators from JavaScript \verb|!=| and \verb|==|, are omitted 
as they have semantic issues, such as not being transitive \cite{javascript-good-parts}.

The current assignment operators supported by the language are: \verb|=|, \verb|+=| and \verb|-=|.
The remaining will be added in the next version.
The conditional operator ``\verb|? :|'' is supported. The comma operator ``\verb|,|'' is not supported, as that is generally considered bad programming style \cite{crockford-web}.

\subsection{Statements}
Statements are terminated by semicolon \verb|;|.
A blocks consists of a sequence of statments within curly brackets \verb|{|$\cdots$\verb|}|. A block may, for example, be used in conjunction with \verb|if| or \verb|function| declaration. Notice that in EcmaScript, and thereby also in LightScript, a block is not a scope limit. In LightScript, blocks are only allowed, where they could actually be needed, e.g. in conjunction with different conditional/iteration statements, function declaration and try/catch.

The conditional and iteration statements supported by LightScript are: \verb|if|, \verb|do|$\cdots$\verb|while|, \verb|while|, and \verb|for|, which work similarly to their EcmaScript counterparts.

Functions can be exited with the \verb|return| statement, where the optional argument to the return statement is the value returned.

LightScript does not support the \verb|with| statement,\footnote{The {\tt with} statement lets properties of an object behave as local variables.} as this is considered bad programming style.

\verb|switch| statements, \verb|break|, \verb|continue| and labelled statements are not supported. In JavaScript a statement is mostly syntactic sugar for a sequence of \verb|if|-statements combined with an anonymous variable, as the expressions of the \verb|case|-clauses are evaluated sequentially and then compared to the result of the expression in the switch clause.
These constructs may be added in later versions of LightScript.

Exceptions are thrown with the \verb|throw| statements, which works as in JavaScript.
The \verb|try| statement is slightly different, as LightScript only supports the \verb|try|$\cdots$\verb|catch| version, and does not currently support the \verb|finally| option.
LightScript also has slightly different scoping rules for the catch block, where the caught variable is an ordinary local scoped variable, whereas JavaScript creates a new object in the scope chain containing only this variable. The motivation for this change is that it is a more consistent approach to scoping, where this would otherwise be a special case, requiring more code space. 
At the same time, it is only in the case that the variable in the catch-statment shadows another variable, that JavaScript and LightScript will be different, and this case should be avoided anyhow, as it leads to more difficult-to-read code. 
\index{Exceptions}

\subsection{Function definitions}
Functions are defined using the \verb|function| keyword, followed by an optional function name, a list of parameters and the function body.
If the function name is specified, a variable with that name assigned to the function.

The LightScript currently does not support a variable numbers of arguments, nor can functions have properties.
Support for variable number of arguments is added in the next version.
Functions are first-class objects, and can be passed around, and used as such. A function applications is expressed with the usual $f$\verb|(|$\cdots$\verb|)|.

\subsection{Native LightScript objects and functions}
The current LightScript implementation only has a small standard library, with the purpose of being a proof of concept to which functions can easily be added. The following functions and methods are implemented:

\paragraph{print(value)} Prints a value to the standard output.
\paragraph{gettype(value)} Returns a string representation of the type of the parameter, either ``object'', ``array'', ``number'', ``undefined'' or ``builtin''. This can be used instead of the \verb|typeof| operator, which in EcmaScript has some semantic issues.
\paragraph{parseint(str)} Parses a string as a base 10 integer, and returns the integer result.
\paragraph{clone(parent)} Creates a new object using the parameter as the prototype.
\paragraph{Array.push(elem)} Pushes an element to the end of the array. This is a method of the array prototype.
\paragraph{Array.pop()} Pops an element from the end of the array and returns it. This is a method of the array prototype.
\paragraph{Array.join(sep)} Joins the elements of an array as strings, with separator between neighbours. This is a method of the array prototype.
\paragraph{Object.hasOwnProperty(name)} Determines whether the object has a (non-inherited) property of the given name. This is a method of the object prototype.
\paragraph{*.length} A special property, indicating the length of an array or string, or the number of properties in an object.


% []subscript []array . {}hashtable {}block >> * %  ()function-call ()paren + - === !==  <= < >= > && || else in ?: = += -= var return ! ++ -- throw try catch function do-while while for if this undefined/null/false true "string" 123number



\section{Developer guide to embedding LightScript in Java}
To evaluate code with LightScript, the developer first has to instantiate a LightScript object, which keeps track of global values, loaded libraries, and the internal compiler state. The constructor takes no parameters, and is used as:
\begin{lstlisting}
    LightScript lsContext = new LightScript();
\end{lstlisting}
The LightScript object is a context that can be used to evaluate LightScript code, using the \verb|eval| method. This method either takes a string or an \verb|java.io.InputStream| as parameter, which is then read and executed:
\begin{lstlisting}
    lsContext.eval("print(\"Hello world \" + 17 * 42);");
    lsContext.eval(new FileInputStream(new File("myscript.js")));
\end{lstlisting}
Global variables of the context can be read and written with the \verb|get| and \verb|set| method, so for example:
\begin{lstlisting}
    lsContext.set("foo", new Integer(17));
    lsContext.eval("bar = foo + 25;");
    System.out.println(lsContext.get("bar");
\end{lstlisting}
would print \verb|42|.

\subsection{Adding native functions to the runtime}

A method of a Java object can be called from LightScript if the object implements the \verb|LightScriptFunction| interface, which defines an \verb|apply| method.
The interface is:
\begin{lstlisting}
public interface LightScriptFunction {
    /** 
     * Method callable from LightScript.
     *
     * @param thisPtr   The this LightScript object, 
     *                  if apply was called as a method.
     *
     * @param args      An array that contains the parameters,
     *                  this is READ ONLY.
     *                  The first parameter is at args[argpos], and 
     *                  the last parameter is at args[argpos + argcount - 1].
     *
     * @param argpos    The position of the first parameter.
     *
     * @param argcount  The number of parameters.
     *
     * @return          An object that is returned to LightScript
     */
    public Object apply(Object thisPtr, Object[] args, int argpos, 
                        int argcount) throws LightScriptException;
}
\end{lstlisting}
So, for example, a function that returns the current number of milliseconds could be implemented as:
\begin{lstlisting}
class MillisecondsFunction implements LightScriptFunction {
    public Object apply(Object thisPtr, Object[] args, int argpos, 
                        int argcount) throws LightScriptException {
        return new Integer((int)System.currentTimeMillis());
    }
}
\end{lstlisting}

Adding a function to the runtime is just like adding any other variable,
via the \verb|put| method of the LightScript object.
So the function above can be used to perform some timings in LightScript as follows:
\begin{lstlisting}
    lsContext.set("timer",new MillisecondsFunction());
    lsContext.eval("begin = timer();"
                  +"for(i=0;i<1000000;++i);"
                  +"print(\"Time used: \" + (timer() - begin));");
\end{lstlisting}

When registering several functions, it is more compact to join them via a dispatch, 
so a class implementing several functions could be implemented as follows:
\begin{lstlisting}
class FunctionLibrary implements LightScriptFunction {
    int id; // This tells which function the object represents
    public Object apply(Object thisPtr, Object[] args, int argpos, 
                        int argcount) throws LightScriptException {
        switch(id) {
            case 0: // integer division
                return new Integer(((Integer)args[argpos]).intValue()
                                  /((Integer)args[argpos+1]).intValue());
            case 1: // increment property i, not of superclass
                int i = ((Integer)((Hashtable)thisPtr).get("i")).intValue();
                ((Hashtable)thisPtr).put("i", new Integer(i + 1));
        }
        return null;
    }
    private FunctionLibrary(int id) { this.id = id; }
    public static void register(LightScript lsContext) {
        lsContext.set("div", new FunctionLibrary(0));
        lsContext.set("propinc", new FunctionLibrary(1));
    }
}
\end{lstlisting}
which could be used like:
\begin{lstlisting}
    FunctionLibrary.register(lsContext);
    lsContext.eval("obj = {}; obj.i = 1; obj.inc = propinc;"
                  +"while(obj.i < 10) {"
                  +"  print(div(42, obj.i));"
                  +"  obj.inc();"
                  +"}");
\end{lstlisting}

\subsection{Datatypes}
LightScript uses ordinary Java objects for most data.
Strings, stacks, tables, are implemented using the standard Java classes.
Boolean values are the constants \verb|LightScript.TRUE| and \verb|LightScript.FALSE|, instead of Java Booleans as that improves performance, as we can just do a pointer comparison, rather than first casting to the Boolean class followed by a method call to retrieve the boolean value.

LightScript objects are instances of \verb|java.lang.Hashtable|. If a LightScript object is cloned from another object, it is an instance of the \verb|LightScriptObject| class, which is subclass of \verb|java.lang.Hashtable|. LightScript objects have a constructor that corresponds to clone in Self, described in Section~\ref{survey-self}, and the parameter to the constructor is a LightScript object, either as a \verb|java.lang.Hashtable| or a \verb|LightScriptObject|. \verb|LightScriptObject| overloads the \verb|get| operator of the hashtable superclass, such that when the key is not found in the current object, it does a lookup in the prototype from which the object was cloned.

Exceptions that can be thrown to/from LightScript are of the class \verb|LightScriptException|. This exception has a property \verb|value| that is the object that is thrown/caught within LightScript. The constructor just takes the value as an argument.

\section{Versions and future directions}
\index{Future works}
The LightScript version described above is version 1.0.426

The version number consist of a major version number, a minor version number and a revision number.
The major version number is incremented at major rewrites and redesign.
The minor version number is incremented with milestones and expansions of language/added functionality, it uses an even/odd strategy, such that even minor versions get bugfixes, and the odd minor versions are development versions where the new features are added, i.e. 
the features intended for version 1.2 are implemented in versions 1.1.\emph{something} and when all of them are added, the minor version number increases to 1.2, where only bug fixes will be added.
The revision number correspond to the svn version, and is incremented on each commit.

The following is the roadmap of scheduled changes to LightScript version 1:
\begin{itemize}
\item[1.0]
Prototype for thesis and proof of concept.
Version 1.0 is the one used for the benchmarks and described throughout this report, unless otherwise mentioned. 
\item[1.2]
Expansion of language and standard library, more operators from EcmaScript are added,
and an additional fixed point number representation will be added. 
More constructs from EcmaScript should be added, including distinction between false, null and undefined.
\item[1.4]
Extra optional libraries to make the language more useful for practical applications.
\end{itemize}

As the benchmarks in the next chapter show, version 1.0 fullfills the goal of a small code footprint and decent performance.
Version 1.2 and 1.4 will add more functionality at a tradeoff of footprint and performance degradation, but should still be possible to keep it small the footprint reasonable small. Some functionality may optionally be left out at the compile time.



\subsection{Roadmap towards version 1.2}
Whereas the previous parts of this chapter describes LightScript version 1.0, this section describes the most recent changes and updates in the development branch.
In the following is listed what have been done in version 1.1 and what needs to be done before version 1.2
\subsubsection{Implemented changes}
\begin{itemize}
\item Optimise the code footprint by reordering opcode IDs. The saving comes by a smaller dispatch table, is in the magnitude of hundred bytes code footprint, and has no other side effects
\item Add support for fixed-point arithmetic. The cost in code footprint is in the magnitude of a few kilobytes.
\item Distinguish between false, null and undefined.
\item Replace the stack allocation instruction with automatic code to do this, based on metadata of the function object. This does not change to the footprint significantly
\item Let the functions support a variable number of arguments
\item Add optional clean-up code when exiting a function, to improve garbage collection. This degrade performance slightly for better reclaimation of runtime memory
\item Add prototype object to functions
\end{itemize}
Unless otherwise mentioned, each of these changes addes in the magnitude of hundred of bytes or less to the code footprint.

A change toward more EcmaScript-like semantics by having cutom Java-classes for the different types in LightScript, was abandoned as the implementation turned out to be too expensive spacewise.

\subsubsection{Remaining tasks}
\begin{itemize}
\item Make the fixed-point arithmetic optional.
\item Generalise the system for builtin objects, making it even easier to add support for using plain Java classes from within LightScript, i.e. LightScript-getter/setter interface
\item Let the LightScript object implement getter/setter interface. The LightScript object should the represent the global object, and when we are not in a method call, it should be the content of ``\verb|this|''
\item Support for the \verb|new| operator and \verb|.prototype| property to allow existing object oriented JavaScript code to run within LightScript
\item Walk through EcmaScript specification, and add those operators and library functions that do not add too much to the footprint
\item Maybe improve virtual machine by joining common instruction pairs to single instructions (adding superinstructions)
\item Maybe add optional support for floating point numbers
\item Maybe add breaks, continues and/or switches
\item Maybe optimise compiler footprint, by changing code generation for some constructs to syntax tree rewriting
\end{itemize}

\chapter{Benchmarks}
\label{benchmark}
\index{Benchmarks}
The purpose of this chapter is to measure the performance of the newly developed languages, compared to existing scripting languages.
The first part of the benchmark looks at the code footprint, as this is the major limitation on very low end mobile devices, where it may be limited to 64KB for host application and embedded scripting language combined. 
The code footprint is compared to other scripting languages, in Section~5.1.1.
In Section~5.1.2, we look at how the different parts of the LightScript implementation contribute to the code footprint, and finally, in Section~5.1.3, we look at the sizes of Yolan and LightScript when they are embedded in a mobile application where space optimisations are enabled.
The second part of the benchmarking, Section~5.2, looks at the execution speed of the scripting languages.


\section{Code footprint}
This section looks at the code footprint: first footprint estimates are compared for different scripting languages, then details of the footprint of LightScript version 1.0 are investigated, and finally the actual size of the library embedded in a minimal application is found.

\subsection{Comparison with other languages}
Just comparing the JAR file size would yield an unfair comparison as some of the languages have large GUI libraries, which would be included in the size, and count against them.
Similarly, some languages do not optimise/obscurify the JAR file.
So to have a more fair comparison, the size is measured of zip archives\footnote{A JAR file is a zip archive, possibly with some meta data included} where the class files are non-obscurified, and extra libraries are removed, rather than the actual executable JAR.


%To compare the code footprint size across languages, I have added an estimate of the JAR file size. 
%The estimate is done by making a zip archive of the non-obscurified class files,
%trying to exclude class files that are parts of extra libraries.
%The motivation for this approach is to make the comparison more fair, as some of the languages have large GUI libraries,
%which would count against them if we just looked at the JAR file. 
%In addition, compilation of some of the languages is obscurified/optimised by default,
%which would give those an advantage. So this approach should give a more fair comparison.
\index{JAR-file}

\subsubsection{Languages}
\label{codefootprint-languages}
The code size benchmark compares the languages implemented in this project, Yolan and LightScript, to other scripting languages for mobile devices, FScriptMe, Kahlua, Hecl, Simkin, and CellularBasic, and to some general scripting languages,  JScheme, and Rhino.

\index{FScriptME}
FScriptME is the mobile edition of femto-script, which is ``an extremely simple scripting language'' \cite{fscript}. 
Out of the box, it only supports strings and integers as data types -- no compound types -- which limits use somewhat, and it is still in beta, since 2002. 

\index{Lua!Kahlua}
Kahlua \cite{kahlua} is an implementation of the Lua Virtual Machine for Java Micro Edition. 
The implementation requires CLDC-1.1 due to the use of floating point arithmetic, and therfore it does not run on the lowest-end mobile devices, which only support CLDC-1.0.
Unlike the other languages, Kahlua is not a full language interpreter, but only a virtual machine, so the script cannot be executed directly on the device, but needs to be compiled on another computer before being executed.

\index{Hecl}
Hecl \cite{hecl} seems to be \emph{the} major scripting language for mobile devices, or at least the one that keeps popping up at the top of most results, when searching for scripting languages for mobile devices.
It is very portable with different editions running on CLDC-1.0, CLDC-1.1, Android, as applets and as standalone applications.
It has many libraries targeting mobile devices, which in this comparison were removed from the zip file of class files, so as not to give languages with fewer libraries an advantage in the size comparison.
The language is a dialect of Tcl, and is simplified such that arithmetic operators, and the like, are prefix operators, so expressions end up a bit Lisp-like.

\index{Simkin}
Simkin \cite{simkin} is a scripting language embedded in XML, which also runs on mobile devices. It depends on kxml XML library, which is not included in the measured size. 

\index{CellularBasic}
CellularBasic \cite{cellularbasic} is a dialect of Qbasic, implemented for mobile devices. 
It includes a floating point support library which is not included in the measured size. 

\index{Lisp and Scheme!JScheme}
\index{Scheme|see{Lisp and Scheme}}
JScheme \cite{norvig-jscheme} is a small Scheme implementation. We benchmark an early version as later versions have a vastly larger code footprint. It depends on reflection, and therefore it does not run on Java Micro Edition, but it is included because the implementation is compact, and may be changed to target mobile devices.


\index{Rhino}
Rhino \cite{rhino} is a JavaScript implementation. This language is not designed for, nor does it run on, mobile devices. It is included as an example of an implementation of a usual non-mobile scripting language.

\subsubsection{Results}
The approximate JAR sizes of the scripting languages are:
\begin{center}
\begin{tabular}{|c|r|} \hline 
Yolan & 7K \\ \hline 
LightScript & 14K \\ \hline 
\end{tabular}
\begin{tabular}{|c|r|} \hline 
FScriptME & 17K \\ \hline 
Jscheme & 29K \\ \hline 
Kahlua & 39K \\ \hline 
Hecl & 54K \\ \hline 
Simkin & 81K \\ \hline 
CellularBasic & 83K \\ \hline 
Rhino & 397K \\ \hline 
\end{tabular}
\end{center}

The languages developed in this thesis are smaller than other scripting languages for the platform. 
Yolan is approximately half the size of LightScript. 
One of the reasons for this can be that most of the other languages are implemented with nice object oriented designs on top of Java. Yolan and LightScript has been implemented with code space optimisations in mind from the very beginning, and with a focus on the generated JVM code rather than just using the abstractions of Java.

FScriptME is also quite small, and looking at its source, it has few Java classes, and it relies on the standard Java classes for types. Another cause of the small code size, may be size of the language which only has strings and integers as datatypes. Approximately 80\% of the source code of FScriptME is its lexer and parser class. 

\subsection{Details on the footprint of LightScript}
The sizes of the different parts of the LightScript class are listed below.
``Reduction'' is the reduction of the full class file when the mentioned part is left out. ``Alone'' is the size of the class containing only the mentioned part. These numbers are different as some things are shared and some things cannot be left out when compiling the class file.

\begin{center} \begin{tabular}{|r|r|rl|} \hline
&\multicolumn{1}{|r|}{Reduction} & \multicolumn{2}{|l|}{Alone}\\ \hline
Everything & 15030 & 17706 & \\ \hline
Embedding API & 645  & 3597  & \\ \hline
Tokeniser & 1261 & 4048 & \\ \hline
Parser & 2542 & 5850 & \\ \hline
Compiler & 5324 & 8413 & \\ \hline
Virtual machine & 4589 & 7650 & \\ \hline
Parser+Tokeniser & 3825 & 7093 & \\ \hline
\end{tabular} \end{center}

There is nothing particular surprising about these result. 
The code footprint is mainly split the three main parts: parser/tokeniser, compiler, and virtual machine, which are similar in size. Worth noticing is that the parser/tokeniser is the smallest of the three parts, indicating that a top-down-operator-precedence parser can be quite small. 


\subsection{Optimised JAR-file footprint}
\index{JAR-file}
Previous sections have looked at comparable footprints for implementations by approximated JAR file size, and also at what parts contributes to the size of the LightScript class.
From a practical view it is also interesting to consider the actual size of the optimised obscurified JAR-file of embedding the languages in a trivial host application.
The host application is a simple Midlet that adds a print function to the language, and includes a hello-world program.
The size of the entire application, including the embedded scripting language implementation is 5290 bytes for Yolan and 11342 bytes for LightScript.

\section{Execution speed}
This section benchmarks the execution speed of the languages. 
In the following subsections, the benchmarked languages, and the actual benchmark programs are described, and finally the results of running the benchmarks are tabulated. 
%The source code for the benchmarks can be seen in appendix~\ref{benchmarksource}.
%TODO: Julia running the benchmarks are tabulated I see that tabulation is all that is done, but it would be nicer to say "assessed" and then give a proper assessment there.

% TODO: Julia: In the results section, I missed to have some assessment of the number.  I see that it appears in chapter 6, but the reader really wants some interpretation of the numbers right away.  For example: Why do some languages do well?  Why do some not do well?  Why does lightscript sometimes do better than Yolan, and vice versa.  Why does lightscript do badly on Fannkuch?

\subsection{Languages}
The benchmarks are run on those languages from Section~\ref{codefootprint-languages} that have an approximated JAR size of less than 64K. They also run on two JavaScript interpreters: Rhino 1.6r7 and SpiderMonkey 1.7.0, which are described in Section~\ref{spidermonkey}. Both are the default versions installed on Ubuntu Linux.

\subsection{The benchmarks}
The benchmarks are the following:

\paragraph{Fibonacci:} Recursive calculation of the 30'th Fibonacci number
\paragraph{Loops:} Nested loops with counters, 10.000.000 iterations
\paragraph{Recursion:} Recursive benchmark, similar to the ``controlflow-recursive''  benchmark from \cite{sunspider, shootout}. It runs the ack, fib and tak function, which are highly recursive and uses a lot of stack space. Many of the scripting language runs out of stack space when executing this benchmark.
On some of the languages where it fails, only the first part (the Ackermann function) was implemented.
\paragraph{Sieve:} Simple implementation of Erasthones sieve - not implemented in languages that have already shown to be very slow in earlier benchmarks
\paragraph{For-in:} Nested loops across keys of a dictionary, 1.000.000 iterations - not implemented in languages that have already shown to be very slow in earlier benchmarks
\paragraph{Primes:} Simple primality test by looking at the remainders of division - not implemented in languages that have already shown to be very slow in earlier benchmarks
\paragraph{Exception:} Throw/catch 500.000 exceptions. It is only implemented for LightScript/JavaScript as Yolan does not support exceptions.
\paragraph{Fannkuch:} The access-fannkuch benchmark from \cite{sunspider, shootout}, slightly modified to be able to run within LightScript -- postfix increments replaced by prefix increments, and a \verb|break| within a loop rewritten to a condition. This benchmark calculates and does a sequence of permutations of array elements.  It is also an example of how existing JavaScript code can be ported to LightScript, and is thus only implemented in LightScript/JavaScript.

\subsection{Results}
The measurements of the performance of the different scripting languages are shown below. The timings are seconds per benchmark. $\bot$ indicates that the benchmark does not complete due to running out of stack space.

\begin{center} \begin{tabular}{|r|r|r|r|r|r|r|r|rr|} \hline 
& \multicolumn{2}{|l|}{Fibonacci} & \multicolumn{2}{|l|}{Recursion} & \multicolumn{2}{|l|}{For-in} & \multicolumn{2}{|l}{Exceptions} & \\
& & \multicolumn{2}{|l|}{Loops} & \multicolumn{2}{|l|}{Sieve} & \multicolumn{2}{|l|}{Primes} & \multicolumn{2}{|l|}{Fannkuch} \\
\hline Rhino       & 1.20 & 1.74 & 1.75   & 2.97 & 1.18 & 12.35 & 45.99 & 6.35 & \\ 
\hline SpiderMonkey& 1.28 & 1.71 & $\bot$ & 2.08 & 1.14 & 11.03 & 0.45  & 5.10 & \\ 
\hline LightScript & 1.37 & 3.45 & 2.35   & 1.19 & 0.57 & 11.70 & 0.65  & 11.15 & \\
\hline Yolan       & 1.47 & 2.23 & $\bot$ & 1.95 & 0.32 &  9.20 &  &  & \\
\hline Kahlua      & 2.13 & 1.18 & $\bot$ &  5.73 & 2.26 & 5.49 &  &  & \\ 
\hline JScheme    & 29.77 & 93.22 & $\bot$ & & & & & & \\ 
\hline FscriptME & 176.27 & 112.68& $\bot$ & & & & & & \\ 
\hline Hecl      & 207.96 & 47.21 & $\bot$ & & & & & & \\ 
\hline \end{tabular}
\end{center} 

Rhino, SpiderMonkey, LightScript, Yolan and Kahlua are similar in speed, whereas JScheme, FscriptME and Hecl is a magnitude slower. 
Rhino and LightScript are the only ones which can handle the very recursive benchmark, whereas the others run out of stack space.

The results are discussed more in details in chapter 6.

\chapter{Discussion and future work}
\label{discussion}

This chapter starts with discussion of the benchmark results, with a focus of the possible reasons for the execution speeds in Section~6.1, and the possible reasons for the code footprint sizes in Section~6.2.
Section~6.3 then adds a discussion about the languages developed in the thesis, and finally Section~6.4 will look more into the future directions of LightScript

\section{Performance}
It is interesting to see that Rhino, SpiderMonkey, LightScript, Yolan, and Kahlua are all within the same magnitude of speed for all of the benchmarks, indicating that this is the speed obtainable with a simple interpreter for these kinds of scripting languages. Here it is also suprising, that Rhino and SpiderMonkey are not much faster, because Rhino compile to, and loads, Java classes at run-time, and SpiderMonkey is written in C rather than Java, which allows for using more advanced implementation techniques.

Other observation are that Rhino is slow with exceptions, and that Kahlua seems to be fast with loops and slow with arrays. The last is probably because Kahlua implement arrays as hashtables\footnote{This is different from the C implementation of Lua where they are implemented as arrays.}, and that the \verb|for|-construct in Lua automatically increments and tests the counter variable, whereas this has to be executed as interpreted code in the other languages.

It is also interesting how similar in performance Yolan and LightScript are, even though they have very different evaluation strategies: Yolan is interpreted by traversing a syntax-tree data structure, whereas LightScript runs on a stack-based virtual machine. 

Most of the scripting languages with a small code footprint are an order of magnitude slower than LightScript, Yolan, and Kahlua and the JavaScript implementations.
This may be due to inefficient implementation of variable access in JScheme, FScriptME and Hecl. Looking at the source code, JScheme and FScriptME variables are looked up in a linked list or hashtable at each access. Hecl has a more complex lookup mechanism with a stack of hashtables, but it also employes some kind of caching.

\section{Size}

The scripting languages developed in the thesis has significantly smaller code footprint than other scripting languages for mobile Java devices.
Two reasons for this are: 1) the implementations have focused on code footprint from start to end, using techniques for writing compact code to a much higher degree than existing scripting language implementations for mobile Java devices, and 2) the parsers, which usually would take tens, or more, of kilobytes, has been reduced significantly: in the case of Yolan this was done by having a trivial syntax, and in the case of LightScript by optimising and using top-down operator precedence parsing.

The size comparison is even more favorable, especially for LightScript, when taking the features of the languages into account:
The third language in size, FScriptME, is a very minimalistic language, that does not have builtin support for arrays, objects, higher-order functions, or exceptions, which accounts for its small size.
The next two languages, in fourth and fifth place in size, are JScheme and Kahlua,
having a simple or no parser, due to having Lisp-like syntax or being just a virtual machine.

That the parser is likely to be a bottleneck can be seen in FScriptME, where the parser is 80\% of the implementation. In CellularBasic the source code of the lexer and parser is more than 100KB. 
The cost of parser implementation may also have be an influence on Hecl not supporting Tcl-like \verb|expr| with infix binary operators, but instead Hecl only has comparisons and arithemetic operators written in Lisp-like prefix notation which are simpler to write parsers for.

\section{Developed languages}
\subsection{Yolan}
Yolan does a good job of having a tiny code footprint and decent performance, while being a scripting language with first-class function, hashtables, easy embedding, etc. Nevertheless, it does a bad job trying to do anything else:
the dynamic scoping makes it unsuitable for developing larger applications, and the Lisp-like syntax will probably scare away most developers.
So the major use of this language is probably just to set a bar for how small a code footprint a high-level scripting language can have.

While it has an interesting result, code-size wise, there will probably not be any further developments in this language, other than serving as a stepping stone towards LightScript.

\subsection{LightScript}
LightScript is much more featureful and useful than Yolan. While this comes at the cost of having twice the footprint of Yolan, it is still small compared to other scripting languages targeting mobile devices. 
The JavaScript/EcmaScript-like syntax and semantics should make it much more approachable for other developers, while still having expressive features like supporting closures and higher-order functions.

There are tradeoffs between EcmaScript compliance and size/performance. 
One of those is the joining of \verb|false|, \verb|null| and \verb|undefined|, and not needing the boolean type.
As the overall size and performance of LightScript were better than expected,
that optimisation-tradeoff is probably worth undoing to get better semantics, 
but only an implementation and actual benchmark will show whether this is the case. 

LightScript is definitely a language I will use for developing mobile applications in the future, so my project has been successful by making a tool in that direction.

\section{Future development of LightScript}
\index{Future works}

The further development with LightScript is toward version 1.2, which is described in the LightScript chapter. Another aspect is to make LightScript public available, and expanding the library as discussed below.
On the long term, other possible milestones are optimisation of the byte code, porting LightScript to embedded C, and better development tools for prettyprinting and linting.

\subsection{Making it public}
LightScript is released as open source software. 
Just releasing the source, however, is not enough to make it really usable for others: documentation and examples are also very important, and there also has to be an awareness about the existence of the language, which entails some work on publishing information on the project, including an informative wikipedia page, and press release/posting of articles on news sites related to programming languages and mobile development.
The website \url{http://www.lightscript.net/}, will serve as the main site, and a small dummy page is already put up.

\subsection{User interface and other optional libraries}
Currently LightScript needs custom Java functions to be added for doing anything useful, as there is no library for input/output.
As the language implementation stabilises, the next step is to create a library which can optionally be included within the application.
A lot of standard functionality, such as cryptography, http-networking, storage, etc.,  can relatively easily be merged from the platform, or existing open source libraries. 
Other libraries require further work: One major task here is integration of a graphical user interface with LightScript, as on this point, there are major differences between the platforms on which LightScript runs, both within the APIs on these platforms, and also between the actual platform capabilities.

\subsubsection{User interface}
Additional libraries for LightScript are scheduled for version 1.4, and the major design task here will be the user interface. 
Issues are variation and limitations in resolutions, ranging from screen size of 96x65 pixels, up to full desktops, and input methods from simple phone keypad, to touch-input-only, to multi touch, to regular computers.

A solution that I will pursue is in the direction of zooming interfaces, as these able to scale down to small screens.
Prototypes within the thesis has also headed in the direction of zooming user interfaces, though they have yet to be integrated with the scripting language, and have not yet achived maturity to become a part of this report.
\index{Zooming user interfaces}

\subsubsection{Other optional libraries}

Simple function for getting and parsing web pages will be practical for enabling LightScript as a tool for mobile mashups. This will be a simple heuristic html parser mapping the XML-tree to JsonML\footnote{JsonML is an embedding of XML in JSON, somewhat similar to SXML in Scheme} \cite{jsonml}, which can then easily be interacted with in LightScript.
The access to http-connections are supported within CLDC/1.0 and CLDC/1.1, as well as larger Java platforms, and just needs to be wrapped.


\subsection{Optimising the bytecode}

A way to optimise the execution, and reduce the memeory usage of compiled programs, would be to optimise the byte codes, by joining common code sequences. Which byte codes to combine can be determined by using grammar-based compression techniques on generated code, followed by creating new codes from the found dictionary. 
This reduces the memory usage as the generated code becomes shorter, and it increases the performance, as the joined codes only need a single dispatch for the new code. The cost is a larger code footprint due to the new byte codes. If this is to be implemented, it probably has to wait until more code has been written using LightScript, as a larger amount of code is needed for better generation of dictionaries.

\subsection{Embedded implementation}

Another direction with the development of LightScript is the implementation on non-Java platforms.
Embedded C is very different from Mobile Java: the run-time memory usage is more important than the code footprint, as embedded devices often have larger built-in flash ROM than working memory.

The first target platform for an embedded C implementation will be the Mindstorm NXT, which has 64K of RAM, and 256K of ROM.
\index{Mindstorm NXT}
An optimisation here is to use 16 bit tagged value representing a pointer or small integers, instead of 32 bit words, in order to save memory. 

An interesting implementation aspect to study is the effect of enforcing unique strings. This will cost approximately additional 3 bytes per string, and string creation will be more expensive, but at the same time, there will be no copies of identical strings, which may save significant space, and string comparison is changed to pointer comparision, which is much faster.

\subsection{Lint and prettyprinter}

Another future target is to improve the development environment for LightScript.
As the parser does not support error checking, currently the easiest way to develop LightScript scripts is to use an EcmaScript compliant development platform, and stay within the limits of the LightScript subset.
A LightScript linting program would be a practical tool, as this would also be able to check, if the programmer goes outside the LightScript subset of EcmaScript.
Currently much of this can be caught with debugging in the current version LightScript, but a real linter may also warn about bad usages, and would have more helpful messages to the developer.

Another development tool, possibly integrateable with the linter is a prettyprinter, which is both practical to enforce coding conventions and to keep source readable when several programmers are working on the same project. It may also go beyond just prettyprinting and further may transform some unsupported EcmaScript features into LightScript.

\chapter{Conclusion}
\label{conclusion}
\index{Conclusion}
I have created two new scripting languages targeting mobile devices.

Yolan is a minimalistic scripting language with first-class functions and Lisp-like syntax. This language is a proof of concept that the code footprint cost of an embeddable scripting language for Mobile Java applications, can be kept low, in this case approximately 5 KB.

LightScript is a more advanced language, that has a larger footprint than Yolan, but it still smaller than other languages. LightScript is more developer friendly, being a subset of JavaScript, and it has also more features, such as an object system with inheritance and support for exceptions.
The language and its implementation can be of practical use. I have released it as open source and will develop it further after this thesis.

Yolan and LightScript are pushing the edge of small scripting language implementation on mobile Java enabled devices, by having a smaller code footprint, being fast, and having advanced language features, compared to other scripting language on mobile devices.


%\chapter{Introduction to scripting \\ -- a user guide}
%\input{language/userguide}
%

\newpage
\index{Bibliography}
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{bibliography}
\bibliographystyle{alpha}

\appendix

%\input{../code/bench/marks.tex}
\chapter{Thanks}
\mbox{}\\
Thanks to Julia for supervising this thesis, for giving me the freedom to go in the directions I chose, and for asking questions which saved me from choosing wrong roads. 
Thanks for the immense feedback which has made me a better computer scientist and a better writer. Thanks.


\mbox{}\\
Thanks to MariAnne for hospitality and reading the thesis.\\
Thanks to Lotte for turning my world upside down.\\
Thanks to family, friends and colleagues 

for bearing with me, while I worked on the thesis.\\
Thanks to the computer scientists, mathematicians, and other giants

on whose shoulders I try to climb to see further.\\
And thanks to God, to whom the honour belongs. 

\chapter{Grammar}
This chapter describes the grammar for Yolan and LightScript.
In order to reduce the code footprint of the parsers, the grammars are very lax, and are included to explain the implementation, and are not meant for learning how to program in the languages.

Notation: Literal characters are writen with single quotation mark.
Ranges of possible characters are written within square brackets, such that \verb|[a-c]| means one of the characters a, b or c. Ranges can also be negated, such that \verb|[^a-cf]| means a character that is not a, b, c nor f. A range can also contain escaped characters: \verb|\0| means the character with unicode value 0, and \verb|\\| means the backslash character. \verb|\[|, \verb|\]|, and \verb|\-| means \verb|[|, \verb|]| and \verb|-|. \verb|\n|, \verb|\r|, and \verb|\t| means new line, carriage return, and tab.
Grammar productions are defined with \verb|::=|, parentheses are used for grouping and \verb\|\ is means or. \verb|*| is notation for zero or more occurences of the previous element.

\section{Yolan}
\begin{verbatim}
<number>            ::= [0-9][0-9]*

<identifier>        ::= [^\0- "0-9;\[\]] [^\0- \[\]]*

<comment>           ::= ';' [^\0-\n]* [\0-\n]

<string>            ::= '"' ( [^"] | '\' [\\"] )* '"'

<white space>       ::= [\0- ] 
                      | <white space> <comment>

<white spaces>      ::= <white space>
                      | <white space> <white spaces>

<optional ws>       ::= <white spaces> |

<expressions>       ::= <expression>
                      | <expression> <white spaces> <expressions>

<expression list>   ::= <optional ws> <expressions> <optional ws>

<expression>        ::= '[' <expression list> ']'
                      | <identifier>
                      | <string>
                      | <number>

<program>           ::= <expression list>
\end{verbatim}

\section{LightScript}

The following sections describes the syntax accepted by LightScript 1.1.
The language is very lax to minimise the code footprint of the parser.
\emph{When programming in LightScript, the code should be written such that it is compatible with EcmaScript, and the following grammar should not be used for learning LightScript.} 
This is only expository to give an impression of what the parser accepts, and thus how the syntax can be relaxed to reduce the code footprint.
A example of how lax the syntax is, is demonstrated by the following EcmaScript/LightScript \verb|for|-loop:
\begin{verbatim}
for(x = 0; x < 10; ++x) { 
    print(x); 
}
\end{verbatim}
which also parses and executes in LightScript if written as ``{\tt for\verb|[|x=0,x<10:++x\verb"}" \verb|{| print(x\verb|]|)}''
Correct LightScript code is the only that which is both accepted by the grammar of LightScript, and also is valid EcmaScript.

The next three sections describes the grammar: 
First there is the syntax of the tokens in Section~B.2.1,
then there is a tabulation of the tokens as in the top down operator precedence parser, in Section~B.2.2, and the actual grammer is written in Section~B.2.3.

\subsection{Grammar for tokens}
\begin{verbatim}
<number>            ::= [0-9] [0-9]*

<name>              ::= [_a-zA-Z] [_a-zA-Z0-9]*

<string>            ::= '"' ( [^"] | '\' [\\"n] )* '"'

<comment>           ::= '//' [^\n]* [\n]

<white space>       ::= [ \n\r\t] 
                      | <comment>
                      | <white space> <white space>

<long symbol>       ::= [=!<&|+*/\->%]

<single symbol>     ::= [(),.:;?\[\\\]^{}~]

<symbol>            ::= <long symbol> <long symbol>*
                      | <single symbol>

<literal>           ::= <number> | <string>

<identifier>        ::= <name> | <symbol>

<token>             ::= <literal> | <identifier>

<program>           ::= ( <token> | <white space> )*
\end{verbatim}

\subsection{Top down operator precedence functions}
\verb|<literal>|s are mapped to a syntax tree node which represent a literal value.
If an \verb|<identifier>| is within the table below, the corresponding function are called in the top down operator precedence parser, otherwise the \verb|<identifier>| is just viewed as a reference to a variable.
\begin{center}
\begin{tabular}{lccr}
Tokens & Null denominator & Left denominator & Precedence \\
\verb|.| & & Infix & 7 \\
\verb|( [| & List & Infix list & 7 \\
\verb|/ * % >> /| & & Infix & 6 \\
\verb|+| & & Infix & 5 \\
\verb|-| & Prefix & Infix & 5 \\
{\tt == === != !== } & & Infix & 4 \\
{\tt <= < > >=} & & Infix & 4 \\
\verb+&& || else in+  & & Right infix & 3 \\
\verb|?|  & & Infix3 & 3 \\
{\tt = += -= *= /= \%=} & & Right infix & 2 \\
\verb|function|  & Function case& & \\
\verb|: ; ,|  & Separator & & \\
\verb|] ) }|& List end & & \\
{\tt try catch do }  & Prefix2 & & \\
{\tt for if while }  & Prefix2 & & \\
{\tt ++ -- ! }  & Prefix & & \\
{\tt return throw var}  & Prefix & & \\
{\tt undefined null}  & Single & & \\
{\tt true false this}  & Single & & \\
literal identifier  & Single & & \\
\verb|{|  & List & & \\
\end{tabular}
\end{center}
``Infix'' joins the previous and the next expression in a left skewed tree, whereas ``Right infix'' joins the previous and next expression in a right skewed tree. ``Infix3'' creates a node which combines left expression and the next three right expressions. ``InfixList'' creates a node which takes the previous expression, and reads the next expressions until a ``List end'' is found.

``List`` reads the next expression until a ``List end'' is found. ``Single'' creates a leaf in the syntax tree. ``Prefix'' create a node with the next read expression. ``Prefix2'' create a node with the two next expressions read. ``List end'' is a special node used for terminate lists. ``Separator''s are special nodes, that may be discarded during compilation. ``Function case'' handles \verb|function|s which is a ``Prefix2'' or ``Prefix3'' depending on whether the first parsed expression is a list or identifier. 

\subsection{Grammar}
The following is the grammar accepted by LightScript. 
This uses rules as defined in Section~B.2.1: \verb|<literal>| and \verb|<identifier>|, with the exception that \verb|<identifier>| should not include the tokens which is mentioned in the table in Section~B.2.2.
\begin{verbatim}
<prefix name>       ::= '-' | '++' | '--' | '!' 
                      | 'return' | 'throw' | 'var' 

<prefix2 name>      ::= 'try' | 'catch' | 'do' | 'for' | 'if' | 'while'

<single>            ::= 'undefined' | 'null' | 'true' | 'false'
                      | 'this' | <identifier> | <literal>

<separator>         ::= ':' | ';' | ','

<list start>        ::= '[' | '{' | '('

<list end>          ::= ']' | '}' | ')'
                      | <expr> <list end>

<list>              ::= <list start> <list end>

<function>          ::= 'function' <list> <expr>
                      | 'function' <identifier> <list> <expr>

<expr8>             ::= <prefix> <expr>
                      | <prefix2> <expr> <expr>
                      | <single>
                      | <separator>
                      | <list>
                      | <function>

<expr7>             ::= <expr8>
                      | <expr7> '.' <expr8>
                      | <expr7> ('(' | '[') <list end>

<expr6 operator>    ::= '/' | '*' | '%' | '>>' | '/'

<expr6>             ::= <expr7>
                      | <expr6> <expr6 operator> <expr7>

<expr5>             ::= <expr6>
                      | <expr5> ('+' | '-') <expr6>

<expr4 operator>    ::= '==' | '===' | '!=' | '!==' 
                      | '<=' | '<' | '>' | '>='

<expr4>             ::= <expr5>
                      | <expr4> <expr4 operator> <expr5>


<expr3 operator>    ::= '&&' | '||' | 'else' | 'in' 

<expr3>             ::= <expr4>
                      | <expr4> <expr3 operator> <expr3>
                      | <expr3> '?' <expr3> <seperator> <expr3>

<expr2 operator>    ::= '=' | '+=' | '-=' | '*=' | '/=' | '%='

<expr>              ::= <expr3>
                      | <expr3> <expr2 operator> <expr>

<program>           ::= <expr>*

\end{verbatim}

\chapter{Source code of the Yolan class}
\index{Yolan!source code}
\lstinputlisting{Yolan.java}

\chapter{Source code of the LightScript class}
The following is the source code for the \verb|LightScript.class| of version 1.1.509.
\index{LightScript!source code}
\lstinputlisting{LightScript.javapp}


%\newpage
%\addcontentsline{toc}{chapter}{Index}
%\printindex

\end{document}
